
## 数据库

事务交易

```
-- name: GetAccount :one  
SELECT * FROM accounts  
WHERE id = $1 LIMIT 1;  
  
-- name: GetAccountForUpdate :one  
SELECT * FROM accounts  
WHERE id = $1 LIMIT 1  
*FOR NO KEY UPDATE;*

```

区别

1. `GetAccount`
- 普通查询，只读取数据。
    
- 不加锁，多个事务可以并发读取同一行数据。


1. `GetAccountForUpdate`

- 加了锁，属于 **行级锁**。
    
- `FOR NO KEY UPDATE` 是 `FOR UPDATE` 的弱化版本，只锁定数据行本身，不锁定主键/唯一键。
    
- 阻止其他事务执行 `UPDATE`/`DELETE` 该行，但允许它们执行 `SELECT`。
    
- 常用于事务中，需要修改该行但不改主键的场景，防止并发修改冲突。



- `FOR UPDATE` 会对选中的行加**排他锁（Exclusive Lock）**。
    
- 当第一个事务执行这条语句后，它就**锁住了该行**，直到事务结束。
    
- 第二个事务想对同一行加 `FOR UPDATE` 锁，会发现行已被锁住，所以它**必须等待第一个事务释放锁**



### 锁强度等级（从强到弱）：

1. `FOR UPDATE`：最强，阻止一切修改。
    
2. `FOR NO KEY UPDATE`：略弱，不阻止其他事务更新主键。
    
3. `FOR SHARE`：共享锁，允许读，阻止写。
    
4. `FOR KEY SHARE`：最弱，允许几乎所有操作，主要防止 DELETE。





` docker exec -it postgres12 psql -U root -d simple_bank`  验证事务 各种形式的区别


```sql
// run n concurrent transfer transaction  
for i := 0; i < n; i++ {  
    txName := fmt.Sprintf("tx %d", i+1)  
    go func(i int) {  
       ctx := context.WithValue(context.Background(), txKey, txName)  
       result, err := testStore.TransferTx(ctx, TransferTxParams{  
          FromAccountID: account1.ID,  
          ToAccountID:   account2.ID,  
          Amount:        amount,  
       })  
       errs <- err  
       results <- result  
    }(i)  
}
```

*context.WithValue(context.Background(), txKey, txName)* 用法！


含义是：

- 以 `context.Background()` 为父 context，
    
- 添加一个 key 为 `txKey`，value 为 `txName` 的键值对，
    
- 返回一个新的 `context.Context`（不可变的）。
    

---

###  作用：

这个上下文可以在函数调用链中向下传递数据，例如：

- 传递请求 ID、用户信息、事务对象等
    
- 常用于日志记录、数据库事务传递


`context.WithValue` **不能**用于传递业务数据，只适合传递少量跨中间件所需的数据。




### 排查死锁


```sql
BEGIN;

INSERT INTO transfers (from_account_id,to_account_id,amount) VALUES(1,2,10) RETURNING *;

INSERT INTO entries (account_id,amount) VALUES(1,-10) RETURNING *;
INSERT INTO entries (account_id,amount) VALUES(2,10) RETURNING *;

SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = 90 WHERE id = 1 RETURNING *;

SELECT * FROM accounts WHERE id = 2 FOR UPDATE;
UPDATE accounts SET balance = 110 WHERE id = 2 RETURNING *;

ROLLBACK
```


当一个表执行插入的时候 另一个表执行select出现了 阻塞！

`答案：因为事务 A **还没提交**，所以插入的数据**对其他事务不可见**，还持有锁。`


(postgres 锁) [https://wiki.postgresql.org/wiki/Lock_Monitoring]


Postgres MVCC 


MVCC，即**多版本并发控制**，是一种用于处理数据库中并发操作的机制。 *在传统的并发控制方式中，常见的做法是通过锁定资源来确保在某一时刻只有一个事务可以修改或读取数据*，以防止数据不一致或冲突。 然而，*传统的锁定机制可能会导致性能瓶颈和并发性下降，尤其在高并发访问的情况下。* MVCC通过引*入多个数据版本来解决传统锁定机制的一些局限性*。 在MVCC中，*每个数据库事务在读取数据时会看到一个特定的版本，这使得事务之间可以同时进行读写操作，而不会相互干扰*。 每个*事务可以操作自己的数据版本，从而实现了更高的并发性和更好的性能。*



执行排查锁的语句

![[MVCC原理.png]]

未提交的 INSERT 会锁住新插入的行，其他事务查询这行时会阻塞，直到提交或回滚。


查找锁


![[寻找sql中的锁.png]]




**外键约束会引发锁冲突**，尤其是在主表（`accounts`）被更新或子表（`transfers`）被插入时。

会导致更新 `accounts.id` 的事务，加锁这个主键行。



 ###  发生阻塞的原理：

1. **外键引用**要求数据库在插入/更新时检查目标行是否存在。
    
2. 为了避免并发过程中误判断（如：主表更新后你还没看到），数据库必须在：
    
    - **子表插入外键引用时锁主表行（共享锁）**
        
    - **主表更新主键时加排他锁**
        
3. 这两个锁互相冲突，**就会导致阻塞**。



### 由外键引发的锁冲突原理

 🏙️ 场景设定：城市银行系统

假设我们有一个银行数据库，有两张表：
- `accounts` (账户表) - 存储所有客户账户
- `transactions` (交易表) - 记录所有转账交易

它们通过外键关联：每笔交易必须关联一个有效的账户ID。

 🚦 外键约束如何工作

外键就像银行的保安，确保：
1. 你不能删除一个还有交易记录的账户（参照完整性）
2. 你不能创建一笔指向不存在账户的交易

 🚗 交通堵塞(锁冲突)是如何发生的

#### 情景1：删除账户时的堵塞
```sql
-- 事务A (银行柜员1)
BEGIN;
DELETE FROM accounts WHERE id = 123; -- 想删除账户123
-- 此时保安(外键)要检查是否有交易关联这个账户
```

同时：
```sql
-- 事务B (银行柜员2)
BEGIN;
INSERT INTO transactions (account_id, amount) VALUES (123, 100); -- 想给账户123新增交易
```

***这时就发生了"交通堵塞"：***
- ***事务A要删除账户123，必须先锁定它，防止新交易加入***
- ***事务B想新增交易到账户123，需要确认账户存在***
- ***两者互相等待，形成死锁***

#### 情景2：转账时的连锁堵塞
```sql
-- 事务A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 123; -- 从账户123扣款
```

同时：
```sql
-- 事务B
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 456; -- 向账户456存款
INSERT INTO transactions (from_account, to_account, amount) 
VALUES (123, 456, 100); -- 记录这笔交易
```

这里外键约束需要检查账户123和456是否存在，可能导致锁等待。

 🚑 解决"交通堵塞"的方法

1. **优化事务顺序**：就像调整车流方向
   - 总是按照相同顺序访问表(先accounts后transactions)

2. **减少事务时间**：让车辆快速通过
   - 尽量缩短事务持续时间

3. **使用索引**：增加更多车道
   - 确保外键列有索引

4. **调整隔离级别**：改变交通规则
   - 在某些情况下使用READ COMMITTED而非SERIALIZABLE

5. **批量操作优化**：错峰出行
   - 避免高峰时段(系统繁忙时)执行大批量操作

### 形成死锁

```sql
simple_bank=# INSERT INTO entries (account_id,amount) VALUES(2,10) RETURNING *;
 id | account_id | amount |          created_at
----+------------+--------+-------------------------------
 34 |          2 |     10 | 2025-05-07 09:25:54.744344+00
(1 row)

INSERT 0 1
simple_bank=# INSERT INTO entries (account_id,amount) VALUES(1,-10) RETURNING *;
 id | account_id | amount |          created_at
----+------------+--------+-------------------------------
 35 |          1 |    -10 | 2025-05-07 09:25:54.744344+00
(1 row)

INSERT 0 1
simple_bank=# INSERT INTO entries (account_id,amount) VALUES(2,10) RETURNING *;
 id | account_id | amount |          created_at
----+------------+--------+-------------------------------
 36 |          2 |     10 | 2025-05-07 09:25:54.744344+00
(1 row)

INSERT 0 1
simple_bank=# SELECT * FROM accounts WHERE id =1 FOR UPDATE;
ERROR:  deadlock detected
DETAIL:  Process 90 waits for ShareLock on transaction 651; blocked by process 83.
Process 83 waits for ShareLock on transaction 650; blocked by process 90.
HINT:  See server log for query details.
CONTEXT:  while locking tuple (0,49) in relation "accounts"
```


#### 解答

你这个报错是典型的 **死锁（deadlock）**，下面直接用简单语言解释你这个具体场景发生了什么：

---

 💥 报错信息核心解释：

```txt
ERROR:  deadlock detected
Process 90 等待 651 的 ShareLock，被 83 阻塞；
Process 83 等待 650 的 ShareLock，被 90 阻塞。
```

**两个事务互相持有对方需要的锁，造成死锁，Postgres 自动中止其中一个事务。**

---

 🧠 死锁成因分析：

你执行的是下面两类语句：

```sql
-- 插入 entries（带 account_id 外键），触发对 accounts 表中 id=1、2 的共享锁
INSERT INTO entries (account_id, amount) VALUES (...);

-- 查询 accounts 并 FOR UPDATE（排他锁）
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
```

---

 🧩 推测发生的步骤如下（两个事务交叉执行）：

 假设：

- **事务 A**：先插入 `account_id = 2` 的 entry
    
- **事务 B**：先插入 `account_id = 1` 的 entry
    

 锁的持有情况：

| 操作                       | 拥有的锁                          | 需要的锁            |
| ------------------------ | ----------------------------- | --------------- |
| 事务 A 插入 entry(2)         | `accounts.id = 2` 的共享锁        | ——              |
| 事务 B 插入 entry(1)         | `accounts.id = 1` 的共享锁        | ——              |
| 事务 A `FOR UPDATE id = 1` | 需要 `accounts.id = 1` 的**排他锁** | 被 B 占用（共享锁）→ 阻塞 |
| 事务 B `FOR UPDATE id = 2` | 需要 `accounts.id = 2` 的**排他锁** | 被 A 占用（共享锁）→ 阻塞 |

就这样，**A 等 B，B 又等 A，死锁形成。**

---

 💡 为什么外键会引发死锁？

因为你的 `entries.account_id` 外键引用 `accounts.id`，插入的时候数据库会：

- 加一个**共享锁**（`ShareLock`）在 `accounts.id` 上，防止它在检查过程中被删或改。
    

但你后面又显式地用 `FOR UPDATE` 想拿 **排他锁**（`ExclusiveLock`）锁 `accounts.id`，两者锁类型不兼容，互相等就容易死锁。

---

 ✅ 解决办法：

 ✅ 方法 1：避免交叉锁顺序

始终按照相同的顺序访问资源（比如先锁 account，再插 entry），比如所有事务都：

1. `FOR UPDATE` 锁定需要的 `accounts`
    
2. 然后插入 `entries`
    

这样可以避免“你拿我需要的，我拿你需要的”。

---
 ✅ 方法 2：插入时使用 `DEFERRABLE INITIALLY DEFERRED` 外键（高级）

延迟外键检查到事务提交时，避免中途加锁，但这个需要创建外键时指定：

```sql
ALTER TABLE entries
ADD CONSTRAINT fk_account
FOREIGN KEY (account_id)
REFERENCES accounts(id)
DEFERRABLE INITIALLY DEFERRED;
```

---

### INSERT INTO entries (account_id, amount) VALUES (...); 为什么会触发共享锁


---

###  原因：PostgreSQL 插入外键时要验证父表行存在

当你执行：

```sql
INSERT INTO entries (account_id, amount) VALUES (1, 100);
```

PostgreSQL 会做两件事：

1. 检查 `accounts` 表中是否有 `id = 1`，防止插入一个无效的外键。
    
2. 为了保证这条 `id = 1` 的 `accounts` 行在检查期间不被其它事务删除或修改 `id`（比如更新或删除），它会在 `accounts.id = 1` 上加一个 **共享锁**。
    

---

###  锁类型说明：

- `FOR UPDATE` 是排他锁（Exclusive Lock），阻止其他读或写。
    
- 插入带外键时，加的是 **共享锁（ShareLock）**，可以并发加多个共享锁，但会阻止别人对该行加排他锁。
    

---

#### 真实例子：

```sql
-- 事务 A
BEGIN;
INSERT INTO entries(account_id, amount) VALUES (1, 100); -- 加共享锁 on accounts.id=1

-- 事务 B
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE; -- 想加排他锁，等不到，共享锁没释放 → 阻塞
```

---


> 插入带外键的数据时，数据库会自动给主表中引用到的行加共享锁，确保这行在事务期间不会被删改，从而保证外键约束不被破坏。

---

### 外键

不是不能用约束（如外键），而是要**清楚它的成本**。外键的**核心优点是数据一致性由数据库保障**，但在**高并发、分布式或事务交错多的系统中，会引发锁竞争甚至死锁**。


####  使用外键的场景：

- 业务简单、读多写少（如 CMS、后台管理系统）
    
- 开发初期，先确保数据一致性，避免程序 bug 写入脏数据
    
- 只有单库或轻量事务，无复杂并发场景
    

####  避免使用外键的场景：

- 高并发写入，比如银行转账、电商下单
    
- 分布式系统，服务之间通过 RPC 协作
    
- 对延迟敏感、锁冲突不能接受

#### 理解外键

`ALTER TABLE "entries" ADD FOREIGN KEY ("account_id") REFERENCES "accounts" ("id");`

"在entries表中，account_id字段的值必须总是存在于accounts表的id字段中"

>**添加外键约束数据库会自动做的事情**

 外键约束深度解析：以银行账户系统为例

这个SQL语句正在为数据库表建立一种父子关系，就像给银行系统添加了一个"账户交易必须真实存在"的规则。让我们彻底理解它的原理和实际影响。
 
 
 ```sql
ALTER TABLE "entries" ADD FOREIGN KEY ("account_id") REFERENCES "accounts" ("id");
```
翻译成自然语言：
"在entries表中，account_id字段的值必须总是存在于accounts表的id字段中"

 🏦 银行系统实例说明

### 表结构
- `accounts`表（父表）：
  ```sql
  CREATE TABLE accounts (
    id BIGSERIAL PRIMARY KEY,
    owner VARCHAR NOT NULL,
    balance DECIMAL NOT NULL
  );
  ```

- `entries`表（子表）：
  ```sql
  CREATE TABLE entries (
    id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,  -- 将要成为外键
    amount DECIMAL NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
  );
  ```

 🛡️ 外键约束的四大守护规则

1. **存在性检查**（INSERT/UPDATE保护）
   ```sql
   -- 会被拒绝（账户999不存在）
   INSERT INTO entries (account_id, amount) VALUES (999, 100);
   -- 错误：insert or update on table "entries" violates foreign key constraint
   ```

2. **防孤儿记录**（DELETE保护）
   ```sql
   -- 当entries表有该账户记录时
   DELETE FROM accounts WHERE id = 1;
   -- 错误：update or delete on table "accounts" violates foreign key constraint
   ```

3. **级联操作**（可选配置）
   ```sql
   -- 可以修改约束使其级联删除
   ALTER TABLE entries 
   ADD CONSTRAINT entries_account_id_fkey 
   FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE;
   
   -- 现在删除账户会自动删除相关entries
   DELETE FROM accounts WHERE id = 1; -- 自动删除所有account_id=1的entries
   ```

4. **锁行为**（你之前问的核心问题）
   - 当修改accounts表时，会检查entries表 → 可能锁定entries表
   - 当插入entries时，会检查accounts表 → 可能锁定accounts表

#### 建议

- 想追求性能，就别靠数据库帮你兜底，一定要**在业务层控制顺序与并发行为**。
    
- 想快速开发、数据不复杂，就让数据库做这份工作。

***目前并不是很理解 这两个建议***


### 可能是这样


 ####  删除外键后带来的变化：

1.  可以插入一个不存在的 `account_id`：
    
    
    `INSERT INTO entries(account_id, amount) VALUES (9999, 100); -- 不会报错，哪怕 accounts 表根本没有 id=9999`
    
2.  删除 `accounts` 表中的一行，不会阻止：
    
    `DELETE FROM accounts WHERE id = 1; -- 不管 entries 表有没有引用 id=1，照样能删`
    
3.  **关联“逻辑”还在，但数据库不管了**，你只能**靠应用层保证数据一致性**。


### `FOR NO KEY UPDATE` 能缓解冲突

 和外键锁冲突的点：

- 插入外键时会给目标行加 **`FOR KEY SHARE`** 锁；
    
- `FOR UPDATE` 会阻止其他事务加 `FOR KEY SHARE` → 导致死锁；
    
- 而 `FOR NO KEY UPDATE` 不会阻止 `FOR KEY SHARE`；  
    👉 所以就**不会和外键插入冲突，不会死锁！**


示例：

```sql
-- 事务 A：
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR NO KEY UPDATE;

-- 同时 事务 B：
BEGIN;
INSERT INTO entries(account_id, amount) VALUES (1, 100);
-- ✅ 不阻塞，因为只是加了 KEY SHARE，不影响 NO KEY UPDATE

```



### 为什么要添加FOR UPDATE

在数据库内部，不加锁的SELECT就像"只瞟一眼"数据：

- 看到的数据可能正在被别人修改
    
- 你后续操作可能基于**过时信息**


```sql
-- 危险的不加锁操作！
BEGIN;
SELECT balance FROM accounts WHERE id=1; -- 看到余额500
-- 此时别人可能已经把余额改成400了！
UPDATE accounts SET balance=500-100 WHERE id=1; -- 会错误覆盖别人的修改！
COMMIT;
```



#### KEY的问题

但是我不清楚 为什么FOR UPDATE会造成死锁 但是 FOR NO KEY UPDATE 会避免死锁

想象数据库表就像银行的不同服务窗口：

### 情况1：`FOR UPDATE` (全功能窗口)

- 你锁定了一个窗口办理"转账+修改个人信息"
    
- 这个窗口**完全被占用**，其他人不能办理任何业务
    
- 如果两个人互相等待对方释放窗口 → **死锁**
    

### 情况2：`FOR NO KEY UPDATE` (专用业务窗口)

- 你只锁定窗口的"转账"功能
    
- 其他人仍可以用这个窗口办理"查询余额"等不冲突业务
    
- 减少了完全阻塞的情况 → **降低死锁概率**







