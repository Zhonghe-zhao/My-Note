

[好的博客](https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)

Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元

多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，*线程之间的通信也正是基于共享的内存进行的*，与重量级的进程相比，线程显得比较轻量。


### 线程之间通信


*线程间通信*： 主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 

*共享内存：*
多个线程访问“同一块内存”，通过读写这块内存来交换信息。

线程间通信（Inter-thread Communication, ITC）是**多个线程之间交换数据或同步执行进度**的机制，在并发编程中非常核心。

一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程 在运行中呈现出间断性

*线程状态：*

阻塞 运行 就绪

多个线程“用同一块内存”来 **传递数据**，这块内存就是它们之间的通信桥梁。


### 共享内存 vs go Go 的 `channel` 

> “不要共享内存来通信，而是通过通信来共享内存。”


这里两个 goroutine 之间没有“共享变量”，而是**通过 channel 传递数据**，更安全。


### WHY

因为多个线程一起操作一块内存时会出现：

1. **竞态条件（Race Condition）**
    
    - 比如你还没写完，我已经读了，结果错乱
        
2. **加锁麻烦，容易写错**
    
    - 要用 `Mutex`、`RWMutex`，一忘记就出 bug
        
3. **不容易调试**
    
    - 问题是随机的、复现难、调试成本高


以 Go 的 channel 为例：

1. **天然同步**
    
    - `ch <- data` 会阻塞，直到有人接收，保证“顺序”
        
2. **避免共享变量**
    
    - 不需要锁、不会乱改数据
        
3. **程序结构清晰**
    
    - 谁发数据、谁接数据，一目了然


