
## 概念

内存逃逸是 Go 语言中一个重要的编译优化概念，它决定了变量是分配在**栈（Stack）**还是**堆（Heap）**上。*理解内存逃逸有助于编写更高效的 Go 程序，减少垃圾回收（GC）压力，提升性能
*。


在 Go 中，变量默认优先分配在**栈**上（因为栈分配和回收更快），但如果编译器发现变量的**生命周期超出了当前函数的作用域**（即被外部引用），就必须将其分配到**堆**上，这个过程称为**内存逃逸**。


## 示例： 
 
 **(1) 返回局部变量的指针**


func escapeToHeap() *int {
    x := 42  // x 逃逸到堆，因为返回了指针
    return &x
}

**分析**：`x` 原本是局部变量，但由于返回了它的指针，Go 编译器必须将其分配到堆上，否则函数返回后栈内存会被回收，导致指针悬空。



 **(2) 闭包引用外部变量**


```go
func closureEscape() func() int {
    y := 100
    return func() int {  // y 逃逸到堆，因为闭包引用了它
        return y
    }
}
```

```go
**f := closureEscape()  // f 是一个函数
fmt.Println(f())      // 输出 100**
```

**分析**：闭包函数引用了 `y`，而闭包可能在 `closureEscape()` 返回后仍然被调用，因此 `y` 必须逃逸到堆。


**(2)示例：**

```go
func passPointer(p *int) {
    fmt.Println(*p)
}
```

```go
// ❌ 大对象可能逃逸
func bigSlice() {
    s := make([]byte, 1<<20) // 1MB
    _ = s
}
```

channel 中的数据，发送了 但是不知道什么时候被接收，这个是



Go 的逃逸分析（Escape Analysis）会判断指针 `p` 是否会**在函数返回后仍然被引用**。如果 `p` 指向的数据（即 `*p`）可能被其他代码（如全局变量、闭包、并发访问等）使用，则 `p` 必须逃逸到堆。


 **4. 关键结论**

|**情况**|**是否逃逸？**|**原因**|
|---|---|---|
|`p` 被存储到全局变量|✅ 逃逸|生命周期需延长|
|`p` 仅被函数内部读取|❌ 不逃逸|栈可安全管理|
|`p` 传给 `fmt.Println`|✅ 可能逃逸|`interface{}` 导致保守分析|


## 合理利用 & 规避 逃避 


闭包函数！

栈空间 变量作用域的问题 

编译时无法确定类型或大小 （接口类型不赋值 切片扩容不确定大小）情况

## Go 内存优化 
golang内存分片的基本原则 

1. 指向栈上对象指针不能被存储到堆中
2. 指向栈上对象指针的生命周期 不能超过该栈对象的生命周期



