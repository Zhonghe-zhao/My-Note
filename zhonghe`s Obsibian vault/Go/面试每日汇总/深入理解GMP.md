
### channel用法很重要！

`ch = make(chan int,5)`

创建了一个缓冲区

![[channel.png]]


保护整个数据结构 ：

1. lock mutex
2. buf unsafe.Pointer
3. 最多存储多少个元素
4. 已经存储了多少元素
5. 每个元素占多大空间

`缓冲区就是一个数组`  channel的缓冲区 大致也就是循环队列   *sendx recvx*两个指针

发送队列 
接收队列
通道状态

初始：
读写下标都为0
等待队列为空

如果缓冲区满了 将数据放入到等待队列中 然后后续如果有空闲空间就会唤醒goroutine从等待队列中拿出元素 并 重新放入到缓冲区中

**示例：**

1. *发送数据*

ch < - 10 

这样发送数据到通道 只有当缓冲区有空闲位置 或者 有协程在等待接收数据才不会发生堵塞

![[channe发送阻塞&非阻塞.png]]


2. 接收数据

~~~
< - ch //将接收结果丢弃
v := < - ch 将接收结果赋值给v

v , ok := < - ch
如果ok为false 表示ch已关闭 v是零值

~~~


![[channel接收阻塞&非阻塞.png]]



这里的select 只是对单个通道进行

#### 多路select

多路select 就需要存在两个或多个 case分支


![[多路select.png]]




### GMP深度理解

调度器的由来！

单进程单线程模型

多线程多进程操作

调度器调度决定谁来执行！ 时间片切分 进程允许执行的最大时间 

解决了阻塞问题 A阻塞 执行B  进程切换成本

#### 问题：

单个CPU在使用调度器调度任务的执行到底是进行线程切换还是进程切换？

单个 CPU 在使用 **调度器**（比如 Go 的 runtime scheduler 或操作系统的调度器）**调度任务执行时**，如果是在**同一个进程内部**，一般是**线程切换**；如果是**跨进程**，才是**进程切换**。

**总结一句话：**

- **同一进程内部调度（比如 goroutine、线程）→ 线程切换**
    
- **不同进程之间调度 → 进程切换**

🔹**线程切换**：

- 切换的是**线程上下文**（寄存器、堆栈指针等）
    
- 代价小（相对于进程切换）

🔹**进程切换**：

- 切换的是**整个进程的上下文**（包括内存地址空间）
    
- 代价大（需要更多保存和恢复操作）

Go 语言里的调度更细一点：

- Goroutine 切换 → 是用户态**协程调度**，比线程切换还轻量。
    
- Goroutine 绑定在线程（M）上跑，线程由内核调度，线程之间抢占 CPU。

 提高CPU的利用率！


同步竞争（锁 资源竞争）



#### 问题

疑惑的地方 虚拟内存的空间大约为4G 但在使用的时候只有被使用的页的内存才会被真正的使用 而4G的虚拟内存不可能全部被使用的吧？如果要是这样仅仅几个程序就会被虚拟内存给用完？或者说如果一个应用进程了一个虚拟内存4G如果没有被使用到的部分是否会可以被其它程序拿来使用？




*虚拟内存 ≠ 物理内存**：4G是进程能"寻址"的范围，不代表实际占用物理资源。

- **按需分配**：只有进程实际访问的内存页（通过缺页中断）才会分配物理内存或磁盘交换空间。

- **共享性**：多个进程的虚拟内存可以映射到同一物理内存（如共享库、内存映射文件）。


- **空白区域只是"地址范围"**：如果一个进程声明了4G虚拟空间但只用了1G，其他3G仅仅是地址数字，不占用任何物理内存或磁盘。
    
- **其他进程不受影响**：每个进程有自己独立的4G虚拟空间（64位系统更大），彼此隔离。进程A的未使用部分不会影响进程B的可用内存。

### **实际场景举例**

- 假设系统有4G物理内存，运行两个进程：
    
    - 进程A：声明4G虚拟内存，实际使用1G物理内存。
        
    - 进程B：声明4G虚拟内存，实际使用2G物理内存。
        
    - **系统总占用**：1G + 2G = 3G物理内存（剩余1G可用），而虚拟内存总和是8G（无实际成本）。
        
- 如果进程A尝试访问其虚拟内存中未分配的3G部分：

![[GMP.png]]


**分类：**

M阻塞 
M空闲

#### 调度器涉及策略

**复用线程**  

1. work stealing：

空闲的M2 会从 别的列入 M1 的本地队列中 如果有空闲的则会偷取过来执行


2. hand off 

g1在p1的运行中阻塞了   M1就会 唤醒或者创建一个新的M  P1移动到新创建的M中   M1绑定阻塞的g1 M就会陷入睡眠或被销毁 cpu切换到别线程的p执行g


**利用并行**

GOMAXPROCS 限定p的个数

= CPU核数/2


**抢占**

 ![[抢占调度.png]]




**全局G队列**

优先顺序 自己本地>全局>偷别人本地的


---

### 第 5 讲


![[go func 执行流程.png]]



  
###  进程线程协程理论


---

2025.4.29

### 



![[go的流程.png]]


