

[TCP与WebSocket的区别](https://segmentfault.com/a/1190000044606476)

[WebSocket编程](https://topgoer.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/WebSocket%E7%BC%96%E7%A8%8B.html)

[net/http包使用](https://cloud.tencent.com/developer/article/2413471)


*WebSocket* 代表着WebSocket通讯协议，提供了一条用于客户端和服务器间实现实时、双向、全双工通信的渠道

### WebSocket主要特征包括：

- **互动性**：支持从客户端到服务器端，也支持从服务器端到客户端的不间断数据流动。
- **即时更新**：可以实现页面的即时更新而无需刷新。
- **低延迟**：通过最小化网络流量和减少数据传输来提高性能，使得延迟降到最低。
- **高兼容性**：大多数现代浏览器都支持WebSocket通信。
- **加密传输**：通过TLS/SSL机制保障数据传输安全。
- **跨平台灵活性**：WebSocket可在多种开发语言和不同平台上实施，并支持移动端应用。


在这之前：轮询，这种做法不仅效率低下，还带来了巨大的网络资源浪费


*TCP* 传输控制协议（TCP）是一种可靠的、基于连接的通讯协议，广泛应用于互联网传输中。它确保网络层的数据安全有效传递，并负责传输层的数据传递管理。



### TCP的核心特性包括：

- **可靠传输**：确保数据包能完整且准确的到达目的地。
- **连接型服务**：在数据传输前需建立连接并在结束后断开连接。
- **流量控制**：调整数据传输速度，防止网络拥堵。
- **拥堵控制**：降低数据传输速度以缓解网络拥堵。
- **数据包头部负担**：需要额外头部信息来维护连接状态和控制流量，导致每个包的有效载荷减少。


###  WebSocket 与 TCP 的异同

WebSocket 作为运行于TCP之上的一种高效通信协议，它提供了长期开启的客户端和服务器之间双向通信通道，与TCP三次握手过程类似。WebSocket的握手通过HTTP完成。建立后，通道保持开放以进行数据交换，确保了TCP协议的可靠性和流量控制。


##### 核心差异

WebSocket和TCP之间的主要差异可总结为：

- **建立连接**: WebSocket除了经典的TCP三次握手以外，还需要 HTTP 协议头中的Upgrade字段以升级至WebSocket连接。
- **数据传输单位**: WebSocket更倾向于以消息为单位传输数据，而TCP则是字节流。
- **数据处理**: WebSocket相对于TCP，添加了数据压缩和消息分片的额外处理。
- **实时性**: 保持连接状态下的WebSocket通讯协议具备更高的实时交互能力。



WebSocket 是建立在 TCP 之上的一种 **全双工通信协议**，它的意义不在于“能不能通信”，而是 **更适合浏览器环境下的实时通信需求**。关键区别如下：

1. **TCP 是传输层协议**，但浏览器无法直接用 TCP，需要基于 HTTP。
    
2. **HTTP 是无状态、单向的请求-响应模型**，不适合持续通信。
    
3. **WebSocket 是在 HTTP 握手后升级连接，变为持久的双向通信**，非常适合：
    
    - 实时聊天
        
    - 在线游戏
        
    - 实时通知
        
    - 股票、币价推送
        

总结：**WebSocket 解决的是“在浏览器中建立高效实时通信”的问题，底层依然用 TCP，只是封装成更易用、兼容浏览器的协议。**

**TCP 本身当然能实现双向通信**，它是全双工协议，通信双方都可以随时发送数据——这点没问题。

但你不能直接在浏览器里用原始 TCP 套接字，**受限于浏览器安全策略**。所以：

- **TCP 是可以双向的**，但在浏览器环境下你没法直接用它；
    
- **WebSocket 是一种“跑在 TCP 上、能在浏览器里用的双向通信协议”**，它补上了 HTTP 无法实时、TCP 无法直接用的这个“断层”。
    

所以核心不是 TCP 能不能，而是 **你能不能在 Web 应用中用 TCP 做你想做的事，WebSocket 就是给你这个能力的协议**。



### **1. HTTP 的痛点（WebSocket 要解决的问题）**

#### **痛点 1：半双工通信（服务器无法主动推送）**

- **HTTP 模型**：必须由客户端发起请求，服务器才能响应（半双工）。  
    **问题**：实时场景（如聊天室、股票行情）需要服务器主动推送数据，但 HTTP 只能通过低效的轮询（Polling）或长轮询（Long-Polling）模拟“推送”，导致高延迟和资源浪费


#### **痛点 2：重复的协议开销**

- **HTTP 请求**：每次通信需携带完整的 Headers（如 `Cookie`、`User-Agent`），即使数据很小（如聊天消息）。  
    **问题**：高频通信时，冗余头部占用大量带宽。

#### **痛点 3：短连接生命周期**

- **HTTP/1.0**：默认每次请求后关闭 TCP 连接，重复握手增加延迟。  
    **HTTP/1.1**：支持连接复用，但仍是“请求-响应”模式，无法实现持久化双向通信。



### **2. WebSocket 的解决方案**

#### **方案 1：全双工实时通信**

- **建立连接后**，服务器和客户端可随时主动发送数据，无需等待请求。  
    **应用场景**：
    
    - 聊天应用（消息即时送达）。
        
    - 多人在线游戏（实时同步玩家动作）。
        
    - 股票行情（服务器持续推送价格变动）。
        

#### **方案 2：低协议开销**

- **初始握手**：通过 HTTP `Upgrade` 头切换协议（仅一次）。  
    **后续通信**：使用轻量级数据帧（头部仅 2~10 字节），大幅减少传输负担。
    

#### **方案 3：长连接持久化**

- **单 TCP 连接**：保持长期活跃，通过心跳（Ping/Pong）保活，避免重复握手。  
    **优势**：降低延迟，适合高频交互场景。



---


### Go：WebSocket编程

学习：

```
 http.ListenAndServe
```



### RESTFULAPI

**核心区别**：RESTful用**HTTP方法**表达操作意图，用**URL路径**定位资源。