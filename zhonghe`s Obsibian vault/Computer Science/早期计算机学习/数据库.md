---
title: postgres
tags:
  - 事务
---

## 事务
---  
参考书籍： 数据库设计  
  
---  
  
我先从事务入手：  
  
## 事务  
  
**概念** ： 与单个用户或者程序执行，完成读取或者更新数据库内容的一个或一串操作  
  
应用程序的一次执行就是一个事务或者多个事务  
  
示例：  
  
简单事务： 更新x员工的工资（涉及：数据库的读和写，和非数据库操作）  
  
复杂事务：删除x的员工记录，并把x员工的事务交付给其他人去做。 （过程中若并非所有的操作都被执行，那么数据库的引用完整性将遭到破坏）（数据库也处于不一致状态）  
  
尽管一致性暂时遭到破坏，但是数据库总是可以从一种一致状态转换到另一种一致的状态  
  
### 数据库最终的结果  
  
1. COMMIT：执行成功，事务最终被提交 （数据库也达到了一种新的状态）  
2. ABORTED：事务没有执行成功 （事务被撤销）则数据库必须要还原事务开始之前的一致状态  
3. 已经提交的事务不能被撤销，只能通过（补偿事务）进行覆盖 消除事务产生的影响  
4. DBMS将在程序正确结束后自动执行COMMIT操作，若不能成功执行则 ROBACK  
5. PARTIALLY COMITTED：若在最后一条语句被执行时产生了 破坏了可串行化或违反了完整约束 因此事务必须被撤销 或者系统出现故障，事务更新的事务没有被安全的写到二级存储设备上（部分提交） 以上两种情况最终都会进入  
6. FAILED（失败状态） 事务无法被提交，或者事务处于ACTIVE状态就被撤销 则 处于FAILED状态  
  
### 事务性质  
  
ACID  
  
1. 原子性：  
2. 一致性：  
3. 隔离性：  
4. 持久性：  
  
事务的隔离级别  
事务隔离级别控制了事务之间的可见性和并发行为。常见的隔离级别包括：  
  
- 读未提交（Read Uncommitted）：在这个隔离级别下，一个事务可以读取其他事务尚未提交的数据。这可能导致脏读（读取了未提交的数据）、不可重复读（同一查询在事务执行期间返回不同结果）和幻读（事务在同一查询中看到不同的数据行）等问题。读未提交的隔离级别最不严格，可能会引发数据不一致问题  
- 读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取已经提交的数据，避免了脏读问题。但是，不可重复读和幻读问题仍然可能出现。因为其他事务可能在事务进行期间提交新的数据，导致不同时间点的查询结果不一致。  
- 可重复读（Repeatable Read）：可重复读隔离级别确保在同一事务内，同一个查询的结果保持一致。这意味着一个事务中的查询不会受到其他事务的修改影响。这可以防止脏读和不可重复读问题，但幻读问题仍然可能出现，因为其他事务可能插入新数据，导致新数据行的出现。  
- 串行化（Serializable）：串行化是最严格的隔离级别，它确保每个事务都在独立的时间段内执行，防止了并发问题。事务按照顺序一个接一个地执行，这可以解决脏读、不可重复读和幻读问题。然而，串行化可能会对性能产生较大的影响，因为事务需要依次执行。  
  
  
事务的隔离级别可以解决脏读、幻读、不可重复读的问题。  
  
1. 脏读： 脏读指的是在一个事务中读取了另一个事务未提交的数据。假设事务 A 修改了某一行数据，但还没有提交。同时，事务 B 尝试读取了事务 A 修改的数据。如果事务 A 最终回滚了，那么事务 B 读取的数据就是不存在的，这就是脏读。脏读会导致不准确的数据展示，因为**读取的数据可能是临时的未经验证的。**、  
2. 不可重复读：不可重复读是指在同一个事务内，多次读取同一数据时，得到不同的结果。这可能是因为在事务执行期间，其他事务修改了数据。例如，事务 A 在读取某一行数据后，事务 B 修改了这行数据，并提交了。现在事务 A 再次读取相同的数据，注重数据：**发现数据已经不同了**，造成了不一致的现象。  
3. 幻读： 幻读是指在同一个事务内，多次查询同一范围的数据时，得到不同的结果。这与不可重复读类似，但幻读关注的是数据的数量变化。例如，事务 A 在查询某个范围内的所有数据时，事务 B 插入了新数据，并提交了。现在事务 A 再次查询同一范围的数据，注重：**发现数据行的数量增加了**，这就是幻读。  
  
---  
  
22.2 并发控制   
讲解了数据库中的一些问题 幻读等  
  
  
[点击这里查看PDF文件] (https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf)

**事务的使用**

1. begin
	开始事务
2. commit
	提交事务的更改

3. rollback
	回滚到更新前的状态


### 操作多个表

表连接！ 

引言：

将一个表中的行与另一个表中的行结合起来，用一个表达式来指定哪些行将被配对。例如，返回所有天气记录以及相关的城市位置。数据库需要拿 `weather`表每行的`city`列和`cities`表所有行的`name`列进行比较， 并选取那些在该值上相匹配的行。

明确指出是哪个表的哪个属性
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather JOIN cities ON weather.city = cities.name;



1. 前置操作：

createdb komablog 

psql komablog 

首先 在终端中创建数据表表

然后导表

\i renew.sql 

2. 中心操作：

`select user.player,twitters.content from users,twitters where users.id = twitters.user_id

where users.id = twitters.user_id **外关联**  

可以使用 as缩短表名！简化操作：

`select u.player,t.content from users as u,twitters as t where u.id = t.user_id

---
#### 问题：

**你的银行系统目前是单进程的还是多进程的？如果是多进程，如何保证数据的一致性和并发处理能力？**

#### 问题：

在多用户同时进行银行转账操作时，如何保证每个操作的原子性？例如，如果两个用户同时发起转账操作，如何避免产生竞争条件或数据不一致的情况？

#### 问题：

如果你在这个项目中使用了 `goroutines` 来处理请求，如何确保请求在并发环境下的正确性和性能？

#### 问题：

你的项目是否考虑过部署到多个服务器或容器中？如果是，你是如何管理多个实例的进程？

**问题：**

你的项目是否考虑过部署到多个服务器或容器中？如果是，你是如何管理多个实例的进程？

**问题：** 

假设你将这个项目部署在生产环境中，如果其中一个进程出现崩溃或异常，你是如何处理的？如何保证系统的高可用性？




---

#### 数据库事务的隔离性：

隔离性(Isolatio)：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止
多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相
互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这
个事务，是不影响其他消费者购买的。