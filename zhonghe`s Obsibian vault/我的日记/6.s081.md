
[6.s081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)

[课程]([https://pdos.csail.mit.edu/6.828/2021/schedule.html](https://pdos.csail.mit.edu/6.828/2021/schedule.html))

阅读文档： https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html

## 0. 操作系统接口

一个*向其他运行中程序*提供服务的特殊程序。每一个运行中程序（称之为**进程**）都拥有*包含指令、数据、栈的内存空间* ， *指令*实现了程序的运算，*数据*是用于运算过程的变量，*栈*管理了程序的过程调用


**进程**通过**系统调用**使用内核服务，系统调用会进入内核，让内核执行服务然后返回。所以 **进程总是在用户空间和内核空间之间交替运行**。

内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间，内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。

### 接口

内核提供的一系列系统调用就是用户程序可见的操作系统接口

| 系统调用                      | 描述                   |
| ------------------------- | -------------------- |
| fork()                    | 创建进程                 |
| exit()                    | 结束当前进程               |
| wait()                    | 等待子进程结束              |
| kill(pid)                 | 结束 pid 所指进程          |
| getpid()                  | 获得当前进程 pid           |
| sleep(n)                  | 睡眠 n 秒               |
| exec(filename, *argv)     | 加载并执行一个文件            |
| sbrk(n)                   | 为进程内存空间增加 n 字节       |
| open(filename, flags)     | 打开文件，flags 指定读/写模式   |
| read(fd, buf, n)          | 从文件中读 n 个字节到 buf     |
| write(fd, buf, n)         | 从 buf 中写 n 个字节到文件    |
| close(fd)                 | 关闭打开的 fd             |
| dup(fd)                   | 复制 fd                |
| pipe( p)                  | 创建管道， 并把读和写的 fd 返回到p |
| chdir(dirname)            | 改变当前目录               |
| mkdir(dirname)            | 创建新的目录               |
| mknod(name, major, minor) | 创建设备文件               |
| fstat(fd)                 | 返回文件信息               |
| link(f1, f2)              | 给 f1 创建一个新名字(f2)     |
| unlink(filename)          | 删除文件                 |

shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。


###  进程和内存

xv6 进程的组成部分：

1. 用户内存空间： **（指令，数据，栈）**


2. 仅对内核可见的进程状态： 

- **xv6 是一个操作系统**，而不是一个普通的程序。它包含了操作系统的核心组件，如进程管理、内存管理、文件系统、设备驱动等。

#### 问题1： 

为什么我可以在我的操作系统上同时运行xv6来进行学习呢？

#### 回答1：

xv6 是作为一个 **虚拟机** 运行的，而不是直接在你的物理硬件上运行。以下是详细的解释：

因为使用了 QEMU： - **QEMU**：一个开源的虚拟化工具，可以模拟完整的计算机硬件。
类似于vm所以可以运行

---

####  xv6 *分时特性* ： 

**分时（Time-sharing）** 是 xv6 的一个重要特性，允许多个进程共享 CPU 资源，通过快速切换进程来实现“同时运行”的效果。以下是 xv6 分时特性的具体实现：

1. **轮转调度算法** ： [时间片轮转调度](https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6)
2.  **上下文切换**
3.  **多进程并发**
4.  **系统调用支持**
5.  **中断机制**


关于 [多CPU，多核，多进程，多线程](https://www.cnblogs.com/raind/p/10077982.html "发布于 2018-12-06 17:26")

#### 问题2：

进程是怎么产生的？ 我们桌面上的一个软件点击打开的过程发生了什么

####  回答2：

 (1) **进程创建**

进程通常通过 **系统调用** 创建

 (2) **进程执行**

创建子进程后，通常会用 `exec()` 系统调用来加载一个新的程序到子进程的内存中，并开始执行。

 (3) **进程终止**

- 进程可以通过 `exit()` 系统调用主动终止，或者因为某些错误（如段错误）被操作系统强制终止。
    
- 父进程可以通过 `wait()` 系统调用等待子进程终止，并回收子进程的资源。


### fork() 进程创建

一次调用会返回两次： 一次是 *父进程* 一次是 *子进程*

示例代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    pid_t pid;
    int x = 1;
    
    pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("child: x = %d\n", ++x);
        exit(0);
    } else if (pid > 0) {
        // Parent process
        printf("parent: x = %d\n", x);
        exit(0);
    } else {
        // Error in fork
        perror("fork failed");
        exit(1);
    }
    
    return 0;
}

```

返回结果：
~~~
parent: x=0
child: x=2
~~~

在 *shell* 中 执行  *./hello*  ：

shell看为父进程， 程序hello看为子进程，

父子进程都有*各自的空间互不干扰* 

程序和进程的*区别*：

程序是代码 ： 存储在磁盘上  在*执行* 是程序以段的形式 *存在于在内存的地址空间*

进程*为正在执行中程序的具体实例*

进程状态： 
1. 运行
2. 暂停
3. 终止


#### 对比
 
  对比fork 和 goroutine

| 特性       | `fork()`         | Goroutine   |
| -------- | ---------------- | ----------- |
| **创建单位** | 进程               | 轻量级线程       |
| **资源开销** | 高（复制整个进程）        | 低（共享地址空间）   |
| **通信方式** | 进程间通信（IPC）如管道、信号 | 通道（channel） |
| **调度**   | 操作系统调度           | Go 运行时调度    |
| **使用场景** | 需要完全独立执行的任务      | 高并发任务       |

#### 问题3：

`如果有两个fork()函数在放在上下句 那么第一个fork出来的子进程是调用两次fork还是一次fork呢？`

#### 回答3：

- **第一个 `fork()`**：创建子进程 C1。
    
- **第二个 `fork()`**：
    
    - 原始进程创建子进程 C2。
        
    - 子进程 C1 创建子进程 C3。
        

因此，第一个 `fork()` 创建的子进程 C1 会调用一次 `fork()`，创建子进程 C3。

**使用gcc编译程序**:

gcc  ~.c -o XXX

./XXX

**理解这段程序的执行顺序**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid;
    pid = fork();  // 创建子进程

    if (pid > 0) {
        // 父进程
        printf("parent: waiting for child to finish\n");
        pid_t child_pid = wait(NULL);  // 等待子进程完成
        printf("parent: child %d finished\n", child_pid);
    } else if (pid == 0) {
        // 子进程
        printf("child: doing some work\n");
        sleep(2);  // 模拟子进程工作
        printf("child: exiting\n");
        exit(0);  // 子进程退出
    } else {
        // fork 错误
        printf("fork error\n");
    }

    return 0;
}
```

   pid_t child_pid = wait(NULL);  // 等待子进程完成  *执行顺序*：
   1.  parent: waiting for child to finish
   2. 打印else里面的pid == 0也就是 子进程： child: doing some work  child: exiting
   3. wait收到了子进程的退出
   4. parent: child %d finished

**父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。**

父进程和子进程唯一的区别：

fork()返回的的进程号不一样 也就是返回两个值 父进程大于0 子进程小于0 


### exec()

加载并执行一个新的程序,替换当前进程的镜像,将指定的可执行文件（如 `./a.out`）加载到当前进程的地址空间中。

- **加载程序**：将指定的可执行文件（如 `./a.out`）加载到当前进程的地址空间中。
- **替换当前进程映像**：当前进程的代码、数据、堆栈等都会被新的程序替换。
- **执行新程序**：新程序开始执行，从其 `main()` 函数开始。
- **不返回**：一旦调用 `exec`，它会完全替换当前进程的执行代码，因此 **不会返回到原来的代码**（如果成功执行 `exec`）。

示例：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/ls", "-l", NULL};  // 执行的程序及参数
    execv("/bin/ls", args);  // 使用 execv 执行 ls 命令
    return 0;  // 如果 execv 执行成功，这行代码永远不会被执行
}

```


---


 `sleep 2000`  执行这句指令 的父进程是bash终端
 `pstree -p` 查看进程树
`echo $$`    是输出当前 shell 进程的 PID，这在一些进程管理和调试过程中很有用

结合 exec

`exec sleep 200`

这样使sleep进程替换了原来的bash进程
如果此时终止睡眠则终端直接关闭，因为sleep进程替换了bash进程

`vim test.sh` shell脚本

~~~
#! /bin/bash

sleep 200
~~~

添加执行权限：

`chmod +x test.sh`

`./test/sh`

执行脚本相当于： 用当前交互的Shell运行了一个shell子进程


#### I/O 和文件描述符

**文件描述符**是一个整数，它代表了一个进程可以读写的被内核管理的对象

文件描述符指向的对象称为“文件”

可以理解为key value 一个整数或者几个整数 对应一个文件

文件描述符和进程相伴相生

每个进程都有一个从0开始的文件描述符空间

0 1 2 

0： 标准输入： 键盘对应的存储空间

1： 标准输出 ： 输出到屏幕所对应的存储空间

`./test > test.txt` 将 程序 结果输出 到 文本文件中  

2： 标准出错 ： 出错信息打印到屏幕

shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符

系统调用 `read` 和 `write` 从文件描述符所指的文件中读或者写 n 个字节  `read(fd, buf, n)` 从 `fd` 读最多 n 个字节 将它们拷贝到 `buf` 中，然后返回读出的字节数

`write(fd, buf, n)` 写 `buf` 中的 n 个字节到 `fd` 并且返回实际写出的字节数


`cat` 的本质实现:

将数据从标准输入复制到标准输出

```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
```


`dup` 

复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符

示例：

```c
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);
```

`dup()` 主要用来复制文件描述符，方便使用多个描述符来操作同一个文件或 I/O 对象。它广泛用于 I/O 重定向、进程间共享文件描述符等场景。 



---

### 关于做题之前的一些建议

1. 了解对指针的运算

p[i] = *(p + i)

(int)p + 1，(int)(p + 1)

1. gdb调试

`make qemu-gdb` 

当 内核悬挂（例如，由于僵局）或无法进一步执行

使用GDB来找出其悬挂的位置 ：

  *run 'make qemu-gdb' in one window*  , *run gdb (riscv64-linux-gnu-gdb) in another windows*

理解程序：
```c
char*
strcpy(char *s, const char *t)
{
  char *os;

  os = s;
  while((*s++ = *t++) != 0)
    ;
  return os;
}
```


`make grade`  查看所有程序是否通过

`./grade-lab-util sleep`  单独 运行某个程序  `or`   `make GRADEFLAGS=sleep grade`

快速查找：

`grep "关键字" 文件名`

#### 1. 下载qemu慢

` cd /mnt/c/Users/30413/Downloads`

在wsl 可以 转换到本地目录

` cp qemu-7.2.16.tar.xz ~`直接就过来了

在wsl中下载qemu实在是太慢了

解压：

`tar xvJf qemu-7.2.16.tar.xz -C /opt/qemu`
`tar tvJf qemu-7.2.16.tar.xz`

成功运行了！

#### 2.`make grade`

解决xv6无法` make grade`

参考仓库：

https://github.com/heeyoung-choi/xv6-lab/blob/main/Makefile

强制删除在git中嵌套的仓库，以避免推送出现问题

`git rm -f --cached xv6-public`

---

### sleep.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
    if (argc < 2 || argc > 2 )
    {
    write(2,"only 1 arguments place write again\n",36);
    exit(1);
    }
    sleep(atoi(argv[1]));
    exit(0);
}
```



### 管道

pipe() **创建了一个文件** 放在内存中 特殊的文件可供读写的一段存储空间

使用文件描述符去操作管道
int fd[2]：

fd的两个元素 fd[0]读取内容 fd[1]写内容 两个文件描述符操作一个管道 

*操作系统对于文件描述符的分配： 在所有的整数中取最小的整数 0 1 2 被使用过了 所以是 3和4分别为 fd[0] fd[1]*

Pipe(fd)

示例：

```c
#include<stdio.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>

int main() {
    int fd[2];
    pipe (fd);
    int pid = fork();
   if (pid == 0) {
    //char* receive = (char*) malloc (100*sizeof(char));
    int *num = (int*) malloc (2*sizeof(int));
    read(fd[0], num, 2*sizeof(int));
    //printf("form father receive is :%s",receive);
    printf("the receive is %d,%d\n",*num,*(num + 1));
   }
   else {
   //char test[] = "hello world";
   int num[4] = {8,4,2,1};
   write(fd[1],num,4*sizeof(int));
   }
    return 0;
}
```


- `dup()` 系统调用用于复制一个文件描述符。 会创建一个新的文件描述符，指向与原始文件描述符相同的文件或资源。


#### 理解命令wc

示例程序:

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]); //利用文件描述符性质，这个dup会占用最小整数0的文件描述符
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
```

#### 问题：

为什么要close(0)

- 当打开一个新文件或复制一个文件描述符时，系统会分配 **最小的可用文件描述符**。
    例如：
    - 如果文件描述符 `0` 被关闭，那么下一个可用的文件描述符就是 `0`。
    - 如果文件描述符 `0` 已经被占用，系统会分配下一个可用的文件描述符（如 `3`、`4` 等）。

为什么不直接使用p[0]呢？？



#### 解答：
 1. **确保 `dup(p[0])` 复制到文件描述符 `0`**

- 如果不关闭标准输入，文件描述符 `0` 仍然指向默认的标准输入（通常是终端）。
    
- 调用 `dup(p[0])` 时，系统会分配一个可用的文件描述符（如 `3`），而不是文件描述符 `0`。
    
- 这样，`wc` 命令仍然会从终端读取输入，而不是从管道读取数据。

1. **`wc` 命令默认从 标准输入（文件描述符 `0`） 读取数据**

- 如果直接使用 `p[0]`，`wc` 仍然会从标准输入读取数据，而不是从 `p[0]` 读取。
    
- 这意味着 `wc` 会等待用户从终端输入数据，而不是从管道读取数据。

 **（2）文件描述符的语义**

- 文件描述符 `0` 是标准输入，许多程序（如 `wc`、`cat` 等）都依赖于这一约定。
    
- 如果直接使用 `p[0]`，需要修改 `wc` 的源代码，使其从 `p[0]` 读取数据，而不是标准输入。这是不现实的，因为无法修改所有命令行工具的源代码。

- `wc` 命令仍然从标准输入读取数据，但它实际上是从管道读取数据。


总结： 关闭标准输入并使用 `dup(p[0])` 的目的是将管道的读端重定向到标准输入。


 `Ctrl+D`，如果你在命令行直接按 `Ctrl+D`，用于表示 **End of File (EOF, 文件结束)**


### pingpong.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"


int
main(int argc,char* argv[])
{
int fd[2];
pipe(fd);

if (fork() == 0)
{
read(fd[0],"received ping\n",14);
close(fd[1]);
write(fd[1],"pong",4);
exit(0)
}else
{
write(fd[1],"ping",4);
close(fd[0]);
read(fd[0],"recdived pong\n",5);
close(fd[0]);
}
wait(0);
exit(0);
}
```

第一次写出来的 错误代码！

最终修改：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

/*对于错误处理第一次整体都没有判断 read write pipe*/
int
main(int argc,char* argv[])
{

char buf[5];
int fd[2];

if (pipe(fd) < 0)
{
fprintf(2, "pipe failed\n");
exit(1);
}

if (fork() == 0)
{
read(fd[0],buf,4);
buf[4] = '\0';
printf("%d received %s\n",getpid(),buf);
close(fd[0]);
write(fd[1],"pong",4);
close(fd[1]);
exit(0);
}else
{
write(fd[1],"ping",4);
close(fd[1]);
read(fd[0],buf,4);
buf[4] = '\0'; // 添加空字符 忘记添加了
printf("%d: received %s\n",getpid(),buf);
close(fd[0]);
}
wait(0);
exit(0);
}
```


*我觉得这段程序可能会导致父子进程之间的相互竞争* 事实可能也是这样


重点：

正确使用 `pipe`、`fork`、`read` 和 `write`，以及关闭文件描述符和等待子进程完成


```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  int p1[2];
  int p2[2];
  if (-1 == pipe(p1) || -1 == pipe(p2)) {
    write(2, "error\n", 6);
  }

  if (fork() == 0) {
    char buf[1];
    read(p2[0], buf, 1);
    printf("%d: received ping\n", getpid());
    write(p1[1], "x", 1);
  } else {
    write(p2[1], "x", 1);
    char buf[1];
    read(p1[0], buf, 1);
    printf("%d: received pong\n", getpid());
  }
  exit(0);
}
```

这是取巧的一段代码


**第一次程序出现的问题：**
1. **父进程没有等待子进程完成**：
    
    - 父进程在读取 `pong` 后直接退出，没有调用 `wait(0)` 等待子进程完成。
        
    - 这可能导致子进程的输出被截断，或者父进程提前退出。
**第二次程序：**

添加wait（）等待子进程完成操作，避免造成竞争


---

#### 文件描述符的疑惑

```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
```

这段程序子进程使用1这个文件描述符后没有关闭，会不会导致父进程无法使用1这个文件描述符呢

#### 解答：

~~~
每个进程都有自己独立的文件描述符表。子进程通过 `fork()` 创建时，会继承父进程的文件描述符表，但子进程和父进程的文件描述符是相互独立的。子进程对文件描述符的操作（如写入、关闭）不会影响父进程的文件描述符。

当子进程调用 `exit()` 退出时，操作系统会关闭子进程打开的所有文件描述符。这些关闭操作仅限于子进程，不会影响父进程的文件描述符。
~~~


因为：

每个进程可以打开的文件描述符数量是有限的（由系统配置决定，可以通过 `ulimit -n` 查看）。如果不关闭文件描述符，可能会导致文件描述符泄漏，最终耗尽系统资源。

在编写pingpong.c时：

因为是对*管道的读写*，*管道的读写*操作是阻塞的。如果不关闭文件描述符，可能会导致进程一直等待，无法正常结束。

- 如果父进程不关闭 `fd[1]`，子进程的 `read(fd[0], buf, 4)` 可能会一直等待，因为父进程的 `fd[1]` 仍然打开，子进程无法确定父进程是否已经完成写入。
    
- 如果子进程不关闭 `fd[1]`，父进程的 `read(fd[0], buf, 4)` 可能会一直等待，因为子进程的 `fd[1]` 仍然打开，父进程无法确定子进程是否已经完成写入。

管道的设计遵循以下规则：

- 如果写入端（`fd[1]`）关闭，读取端（`fd[0]`）的 `read()` 会返回 `0`，表示没有更多数据可读（即文件结束，EOF）。
    
- 如果读取端（`fd[0]`）关闭，写入端（`fd[1]`）的 `write()` 会触发 `SIGPIPE` 信号，通常导致写入进程终止。

**这并不是通过信号实现的**，而是通过管道的文件描述符状态实现的。
如果父进程关闭了 `fd[1]`，子进程的 `read()` 会返回 `0`，表示管道已经关闭，没有更多数据可读。

#### **信号与管道的区别**

- **信号**：是一种异步通知机制，用于通知进程发生了某些事件（如 `SIGINT`、`SIGTERM` 等）。
    
- **管道**：是一种同步通信机制，通过文件描述符的状态（如关闭写入端）来通知读取端


### 文件系统

文件就是一个简单的字节数组， 

- `chdir()` 是一个系统调用，用于改变当前进程的工作目录。




### primes.c

第一次尝试
```c
void fork(int *father_pipe)
{
    int n;
    int pid = fork();
    int son_pipe[2];
    pipe[son_pipe];

    if (pid == 0)
    {
        while (1)
        {
            read(father_pipe[0], &n, sizeof(n));
            for (int i = 2; i < 35; i++)
            {
                if (n % i != 0)
                {
                    write(son_pipe[1], &n, sizeof(n));
                }
            }
        }
        close(father_pipe[0]);
        close(son_pipe[1]);
    }
    else
    {
        int st;
        wait(&st);
    }
}

int main(int argc, char *argv[])
{
    int fd[2];
    int buf[36];
    pipe[fd];

    for (int i = 2; i <= 35; i++)
    {
        write(fd[1], &i, sizeof(i));
    }
    close(fd[1]);
    f(fd);
}
```

我的思想：

父亲传入数据到管道的时候，在函数中应该需要先*fork出一个子进程* 来与*父进程通信*读取，并且我对从管道中读取数据也有点模糊，是一口气全部读出来，还是一个个读取然后做处理，我是想对所有的数字依次被2-35除然后筛选一层层向子进程传递，并最终打印出最终结果

以下是我的想法，并能求出的代码：


```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "stddef.h"


void create_child(int *input_pipe, int divisor) {
    int output_pipe[2];
    pipe(output_pipe); // 创建输出管道

    int pid = fork(); // 创建子进程
    if (pid == 0) {
        // 子进程
        close(input_pipe[1]); // 关闭父进程的写入端
        close(output_pipe[0]); // 关闭子进程的读取端

        int num;
        while (read(input_pipe[0], &num, sizeof(num)) > 0) {
            if (num % divisor != 0 || num == divisor) {
                // 如果不能被当前除数整除，或者数字是当前除数本身，传递给下一个子进程
                write(output_pipe[1], &num, sizeof(num));
            }
        }

        close(input_pipe[0]); // 关闭父进程的读取端
        close(output_pipe[1]); // 关闭子进程的写入端
        exit(0);
    } else {
        // 父进程
        close(input_pipe[0]); // 关闭父进程的读取端
        close(output_pipe[1]); // 关闭子进程的写入端

        if (divisor >= 35) {
            int num;
            while (read(output_pipe[0], &num, sizeof(num)) > 0) {
                printf("prime %d\n", num); // 打印质数
            }
            close(output_pipe[0]); // 关闭读取端
        } else {
            // 将子进程的输出管道作为下一个子进程的输入管道
            create_child(output_pipe, divisor + 1);
        }
    }
}

int main() {
    int fd[2];
    pipe(fd); // 创建初始管道

    // 将数字 2 到 35 写入管道
    for (int i = 2; i <= 35; i++) {
        write(fd[1], &i, sizeof(i));
    }
    close(fd[1]); // 关闭写入端

    // 创建第一个子进程，从 2 开始筛选
    create_child(fd, 2);

    // 父进程等待所有子进程结束
    while (wait(NULL) > 0);

    return 0;
}这段程序并不能正常打印出6.s081课程的素数题目的最终结果，我还应该怎么修改？
```

这段程序的错误：

1. 筛选条件

2. 递归逻辑问题：

正确的做法应该是每个子进程从输入管道中读取第一个数作为新的`divisor`（质数），然后用它筛选后续的数。而原代码强制`divisor`递增，导致后续进程可能使用非质数作为除数

3.  打印时机：

只有当`divisor >=35`时，父进程才会读取`output_pipe`并打印结果。这意味着只有最后一个进程才会打印，而实际上每个进程应负责打印自己筛选出的质数（即第一个接收到的数）





#### 问题 1：

read(input_pipe[0], &num, sizeof(num)) > 0 我并不理解有时候 在read和write中括号后面时常会出现 >0 =0 <0 都是什么意思？ 用while循环的目的又是什么

如何处理对于本身 例如： 2 % 2 == 0 ！


#### 解答 1：
1. read：
- **`> 0`**：成功读取了数据，返回值是实际读取的字节数。
    
- **`= 0`**：读取到文件结束（EOF），表示写入端已经关闭，没有更多数据可读。
    
- **`< 0`**：读取失败，通常是由于错误（如文件描述符无效、管道被意外关闭等）。

2. write：

- **`> 0`**：成功写入了数据，返回值是实际写入的字节数。
    
- **`= 0`**：没有写入任何数据（通常不会发生，除非 `count` 为 0）。
    
- **`< 0`**：写入失败，通常是由于错误（如文件描述符无效、管道被意外关闭等）

`while (read(input_pipe[0], &num, sizeof(num)) > 0)`：

- 持续从 `input_pipe[0]` 中读取数据。

- 如果读取成功（`read()` 返回 `> 0`），则处理数据。

回答2：

直接传递给下一个进程

#### 问题 2：

不理解这里的*数据是一次性全部传入管道一次性读取还是 父进程传入一个数据经过处理后然后再读取*

#### 解答 2：

1. 理解管道特性

管道是一种 **先进先出（FIFO）** 的通信机制。数据写入管道后，会按照写入的顺序依次被读取。管道的读写是 **阻塞的**：

- 如果管道为空，读取端会阻塞，直到有数据写入。
    
- 如果管道已满，写入端会阻塞，直到有数据被读取。

2. 代码中数据是一次性全部写入管道的， 当父进程*关闭写入端，表示数据写入完成*。
3. - 子进程从管道中 **逐个读取数据**，而不是一次性读取所有数据。
- 每读取一个数据，就根据 `divisor` 进行筛选，并将筛选后的数据写入下一个管道。

子进程：
- **逐个处理**：
    
    - 每个子进程从管道中 **逐个读取数据**，处理后再写入下一个管道。
        
    - 数据是 **流式处理** 的，而不是一次性全部读取。
        
- **批量处理**：
    
    - 如果管道中有多个数据，子进程会逐个读取并处理，直到管道为空。

#### 核心代码：

```c
 while (read(input_pipe[0], &num, sizeof(num)) > 0) {
            if (num == divisor) {
                // 如果是当前除数本身，直接传递给下一个子进程
                write(output_pipe[1], &num, sizeof(num));
            } else if (num % divisor != 0) {
                // 如果不能被当前除数整除，传递给下一个子进程
                write(output_pipe[1], &num, sizeof(num));
            }
        }
```



为什么可以持续的读，可以自动检测读完吗？

```c
 while (read(output_pipe[0], &num, sizeof(num)) > 0) {
                printf("primes: %d\n", num); // 打印质数
            }
            close(output_pipe[0]); // 关闭读取端
        } else {
            // 将子进程的输出管道作为下一个子进程的输入管道
            create_child(output_pipe, divisor + 1);
```

*重点解释：*

~~~
管道的写入端关闭

 当父进程写入数据并关闭写入端时，管道的写入端会被标记为关闭。
    
 关闭写入端后，读取端的 `read()` 行为会发生变化：
    
 如果管道中还有数据，`read()` 会继续读取数据。
        
 如果管道中没有数据，`read()` 会返回 `0`，表示写入端已经关闭，没有更多数据可读。
~~~

~~~
- 管道的内部实现会跟踪写入端的状态。
    
- 当写入端关闭时，操作系统会通知读取端，表示没有更多数据会写入管道。
    
- 如果读取端尝试读取数据，但管道中没有数据且写入端已关闭，`read()` 会返回 `0`。
~~~



#### 出乎意料

这段程序并没有成功打印出结果！


---

重新修改 primes.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void create_child(int parent_fd[]) {
    int p;
    // 读取第一个数字，它一定是质数
    if (read(parent_fd[0], &p, sizeof(p)) == 0) {
        close(parent_fd[0]);
        exit(0);
    }
    printf("prime %d\n", p); // 立即打印当前质数

    int child_fd[2];
    pipe(child_fd);

    if (fork() == 0) {
        // 子进程：关闭不必要的文件描述符，递归处理
        close(parent_fd[0]);
        close(child_fd[1]);
        create_child(child_fd);
        exit(0);
    } else {
        // 父进程：过滤并传递剩余数字
        close(child_fd[0]);
        int num;
        while (read(parent_fd[0], &num, sizeof(num)) > 0) {
            if (num % p != 0) {
                write(child_fd[1], &num, sizeof(num));
            }
        }
        close(parent_fd[0]);
        close(child_fd[1]);
        wait(0); // 等待子进程结束
    }
}

int main() {
    int initial_fd[2];
    pipe(initial_fd);

    for (int i = 2; i <= 35; i++) {
        write(initial_fd[1], &i, sizeof(i));
    }
    close(initial_fd[1]);

    create_child(initial_fd);

    // 确保所有子进程结束
    while (wait(0) > 0);
    exit(0);
}
```

疑问：

```c
while (read(parent_fd[0], &num, sizeof(num)) > 0) { if (num % p != 0) { write(child_fd[1], &num, sizeof(num)); } } 
```

 这段程序不是也会把2等过滤掉吗

**管道是队列结构**​  
管道（Pipe）本质上是一个**先进先出（FIFO）的字节流**。每次调用 `read` 读取数据时，读取过的数据会从管道中移除，后续的 `read` 操作只会读取未被读取的数据。

### 输出重定向

#### redirect.c

![[重定向.png]]


---

你不必成为专家， 你花费大量时间开发维护和调试，会了解很多操作系统的知识，
 ls > out 输出重定向
 echo hello > out
 cat < out
 子进程调用exit(1) -> 父进程会接受到子进程的退出   
 exec会丢弃所有复制的内存，并将其替换为
 思考fork的副本复制 复制了所有的内存 所花费的时间
虚拟内存映射
为子进程分配权重

观看完第一集视频，看完第一章内容，还剩两道题没有做

---

 
### find.c

#### *理解 ls.c 程序：*

*理解 ls.c 程序：*

......写起来有点费劲，不太理解

寻求博客帮助：

[有帮助的博客1.](https://www.sheniao.top/os/68.html#morphing)

[有帮助的博客2.](https://www.cnblogs.com/diana-learningcpp/p/15579535.html)

在 Linux 中，只使用 ls 并不会显示 `.` 和 `..`。

- -a：显示所有文件及目录 (ls 内定将文件名或目录名称开头为 "." 的视为隐藏档，不会列出)
- -A：同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)

ls.c程序

1. **`fmtname()` 函数**：格式化文件名。
    
2. **`ls()` 函数**：遍历目录并打印文件信息。
    
3. **`main()` 函数**：解析命令行参数并调用 `ls()`。


 **`fmtname()` 函数**

```c
char* fmtname(char *path) {
    static char buf[DIRSIZ+1];
    char *p;

    // 找到最后一个斜杠后的字符
    for(p = path + strlen(path); p >= path && *p != '/'; p--)
        ;
    p++;

    // 返回格式化后的文件名
    if(strlen(p) >= DIRSIZ)
        return p;
    memmove(buf, p, strlen(p));
    memset(buf + strlen(p), ' ', DIRSIZ - strlen(p));
    return buf;
}
```

1. 从路径末尾向前查找最后一个斜杠（`/`），找到文件名起始位置。
    
2. 如果文件名长度超过 `DIRSIZ`，直接返回文件名。
    
3. 否则，将文件名复制到 `buf` 中，并用空格填充剩余部分。

 思路：

首先确定递归的边界条件之一：第一个参数dir_name是一个文件名。使用fmtname（需要修改一下）处理文件名之后直接比对即可，然后返回函数。find遍历目录的方式和ls基本相同。遍历目录时，遇到.和..两个文件要跳过，遇到文件时就和file_name比对，如果相同就打印这个文件的相对路径。如果遇到了目录，就递归调用search函数。

---


- 中途思考：printf 和 write(1)的区别

| 特性       | `printf`       | `write(1, ...)`  |
| -------- | -------------- | ---------------- |
| **功能**   | 格式化输出          | 原始数据输出           |
| **缓冲机制** | 有缓冲（行缓冲或全缓冲）   | 无缓冲              |
| **易用性**  | 高（支持格式化字符串）    | 低（需要手动计算长度）      |
| **性能**   | 较慢（由于缓冲和格式化开销） | 较快（直接系统调用）       |
| **适用场景** | 通用输出，适合大多数情况   | 底层操作，适合精确控制输出的场景 |

---

#### 指针用法：

```c
char buf[256] = "hello";
char *p = buf + strlen(buf); // p 指向 buf 中字符串的末尾
strcpy(p, " world");         // 在 buf 中追加 " world"
printf("%s\n", buf);         // 输出 "hello world"
```


#### struct dirent 用法


```c
#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *dir = opendir(".");  // 打开当前目录
    if (dir == NULL) {
        perror("opendir failed");
        return 1;
    }

    struct dirent de;
    while ((de = readdir(dir)) != NULL) {  // 读取目录项
        printf("File: %s\n", de->d_name);  // 打印文件名
    }

    closedir(dir);  // 关闭目录
    return 0;
}
```

`de.inum == 0` 

- 目录项仍然存在，但 `inum` 为 `0`，表示该目录项是空闲的或无效的。

`memmove(buf, p, strlen(p));`

-  将文件名从指针 `p` 指向的位置复制到缓冲区 `buf` 中


```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

char*
fmtname(char *path)
{
  static char buf[DIRSIZ+1];
  char *p;

  // Find first character after last slash.
  for(p=path+strlen(path); p >= path && *p != '/'; p--)
    ;
  p++;

  // Return blank-padded name.
  if(strlen(p) >= DIRSIZ)
    return p;
  memmove(buf, p, strlen(p));
  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
  return buf;
}

void
find(char* dir_name, char* file_name)
{
char buf[256];
int fd;
struct stat st;
struct dirent de;


if(fd = open(dir_name,0))
{
    fprintf(2, "find cannot open dir %s\n",dir_name);
    return;
}
if(fstat(fd,&st) < 0)
{
    fprintf(2,"find: cannot stat dir %s\n",dir_name);
}
//如果是文件则直接输出
if(st.type == T_FILE)
{
if(!strcmp(fmtname(dir_name),file_name))
{
    printf("%s\n",dir_name);
}
return;
}

//如果是目录应该遍历目录下的文件
if(st.type = T_DIR)
{
if(strlen(dir_name) + 1 + DIRSIZ + 1 > sizeof(buf))
{
    printf("find: path too long\n");
    return;
}
}
    strcpy(buf, dir_name);
    p = buf + strlen(buf);//定位指针
    *p++ = '/';
struct stat st_temp;
while(read(fd,.&de,sizeof(de)) == sizeof(de))
{

if(de.inum == 0)
{
    continue;
}
    memmove(p,de.name,DIRSIZE);
    p[DIRSIZ] = 0;
if(stat(buf,&st_temp) < 0)
{
continue;
}

if(st_tmp.type==T_FILE)//如果是普通文件
    {
        if(!strcmp(de.name,file_name))//找到文件
        {
        printf("%s\n",buf);//打印文件的相对路径
        }
    }
if(st_tmp.type==T_DIR)//如果是目录
    {
        //递归搜索，使用BFS遍历directory tree
        //禁止遍历. .. 这两个目录
        if((!strcmp(de.name,this_dir))||(!strcmp(de.name,parent_dir)))
        continue;
        find(buf,file_name);//递归搜索
    }
}
return;
}

int
main(int argc, char* argv[]){

if(argc < 3 ) {
    fprintf(2,"too few arguments\n");
    exit(1);
}
find(argv[1],argv[2]);
exit(0);
}
```

第一次完成代码： 有很多问题，代码格式还需要修改！


需要修改很多地方

关键点：

- `while(read(...))` 循环遍历目录项，每次 `read` 取出一个 `de` 结构体，赋值给 `de.name`。
- `!strcmp(de.name, file_name)` 持续比较 `de.name` 和 `file_name`，匹配成功时打印路径。
- 递归调用 `find(buf, file_name)`，在子目录里重复上述过程。

正确代码已推送至仓库： 

[我的6.s081仓库](https://github.com/Whuichenggong/6.s081)

#### 总结find.c系统调用函数：

`find.c` 中使用的操作系统调用函数及其作用如下：

| 函数        | 作用            |
| --------- | ------------- |
| `open`    | 打开目录或文件。      |
| `close`   | 关闭文件描述符。      |
| `fstat`   | 获取文件或目录的状态信息。 |
| `read`    | 读取目录项。        |
| `stat`    | 获取文件或目录的状态信息。 |
| `strcmp`  | 比较文件名。        |
| `strcpy`  | 复制路径字符串。      |
| `memmove` | 复制文件名到缓冲区。    |
| `memset`  | 填充缓冲区。        |
| `printf`  | 输出文件路径或信息。    |
| `fprintf` | 输出错误信息到标准错误流。 |

### xargs.c

如何将指令的结果 作为 参数传给xargs.c

指针含义

```c
char *args[MAXARG]; //  每个元素是一个 char*
args[argc - 1] = p; //将 p 指向的字符串存入args数组的第 argc - 1个位置
```

```c

```



- `xargs` 的作用是将标准输入的内容作为参数，拼接到指定命令的后面。


过程：

1. 初始时，`p` 指向 `buf` 的开头，内容是 `hello too\n`。
    
2. 跳过空白字符（如果有），这里没有前导空白。
    
3. 将 `hello` 作为一个参数，存入 `args`：
    
    - `args = ["echo", "bye", "hello"]`。
        
4. 继续解析，将 `too` 作为一个参数，存入 `args`：
    
    - `args = ["echo", "bye", "hello", "too"]`。
        
5. 遇到换行符 `\n`，解析结束。
    
- 在这个例子中：
    
    1. `echo hello too` 输出 `hello too`。
        
    2. `xargs` 读取 `hello too`，将其解析为参数 `hello` 和 `too`。
        
    3. 将 `hello` 和 `too` 拼接到 `echo bye` 后面，形成 `echo bye hello too`。
        
    4. 最终输出 `bye hello too`。

’\0‘ 作为字符串的结束 

关键代码：

```c
while ((n = read(0, buf, sizeof(buf))) {
        if (n < 0) {
            fprintf(2, "xargs: read error\n");
            exit(1);
        }

        // 将输入数据解析为参数
        char *p = buf;
        while (*p != '\0') {
            // 跳过空白字符
            while (*p == ' ' || *p == '\n') {
                *p++ = '\0';
            }

            // 如果遇到非空白字符，将其作为参数
            if (*p != '\0') {
                args[argc - 1] = p;
                argc++;
                while (*p != '\0' && *p != ' ' && *p != '\n') {
                    p++;
                }
            }
        }

```

今天执行程序测试的时候出现了问题： 

~~~
make: *** No rule to make target 'user/_xargs\', needed by 'fs.img'. Stop.
~~~

就是xargs配置出现了问题 问题应该是在Makfile中

emmm 缩进使用的空格造成了问题！ 直接使用tab就好了

```c
 ((n = read(0, buf, sizeof(buf))) > 0)
```
运算优先级


---
## 1. 第一个进程：

 xv6是如何开始运行的：

进程，它让一个程序可以假设它独占一台机器。进程向程序提供“看上去”私有的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU

xv6 使用页表 为每个进程提供其独有的地址空间。页表将_虚拟地址_*(x86 指令所使用的地址*) 翻译 为_物理地址_(*处理器芯片向主存发送的地址*)

---

### 数据结构： 分页表

用于计算机 操作系统中的 *虚拟内存 系统*，其*存储了虚拟地址到物理地址间的映射*。虚拟地址在访问进程中是唯一的，而物理地址在硬件（比如内存)中是唯一的

**操作系统中使用虚拟内存， 进程会认为 *自己使用了一块大的连续内存*，但是事实 每个进程的*内存散布在 物理内存 的不同区域***

进程和页表都存储在内存中，查询进程数据时，需要访问两次内存， 放入寄存器中加快查询速度

操作系统负责把程序生成的虚拟地址，映射到实际存储的物理内存上  存储虚拟地址到物理地址的映射

![[页表.png]]

---

xv6 为每个进程维护了不同的页表


![[虚拟内存地址.png]]


1. 线程： 每个进程都有一个运行线程 来执行进程的指令 *线程可以被暂时挂起，稍后再恢复运行*   系统在*进程之间切换* 实际上就是*挂起*当前运行的*线程*，*恢复*另一个进程的*线程*

2. 进程的组成： 每个进程都有 *用户栈*  和  *内核栈* ： 进程运行*用户指令*时，只有其*用户栈被使用*，其内核栈则是空的，当进程（通过*系统调用或中断*）进入*内核*时，内核代码就在进程的*内核栈*中执行，进程处于内核中时，其*用户栈仍然保存着数据*，只是*暂时处于不活跃状态* 

3. 线程*交替地使用*着用户栈和内核栈 内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，*内核也能保持运行*

4. 内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行

进程使用系统调用时，处理器转入内核栈中，提升硬件的特权级，然后运行系统调用对应的内核代码， 当系统调用完成时，又从内核空间回到用户空间：降低硬件特权级，转入用户栈 线程可以在内核中“阻塞”，等待 I/O, 在 I/O 结束后再恢复运行

`p->state` 指示了进程的状态：新建、准备运行、运行、等待 I/O 或退出状态中



PC 开机时：  从磁盘中载入 _boot loader_ 到内存并运行 _boot loader_ 把 xv6 内核从磁盘中载入并从 `entry`（1040）开始运行 

分页硬件在此时还没有开始工作；所以这时的虚拟地址是直接映射到物理地址上的


boot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x100000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I/O 设备的。



![[地址映射.png]]

为了让内核的剩余部分能够运行，`entry` 的代码设置了页表 将 0x80000000开始的虚拟地址映射到物理地址 0x0 处 页表经常会这样把两段不同的虚拟内存映射到相同的一段物理内存 


---

## lab3 ：

多路复用 隔离

将一个cpu抽象为一个进程 4核心就是同时或并行四个进程每个核心上都有一个进程 不同的进程之间进行时间复用

exec： 抽象了内存 内存映像 
files： 抽象了磁盘块  
proc.c 有关多路复用
Strong isolation between apps + os

User/kernel modev    

cpu vitual memory：   

page table  将虚拟地址 映射到 物理地址    



查看 kernel/kernel.asm


### gdb调试：

![[gdb调试.png]]


使用 `gdb-multiarch` 指令开启gdb 并且使用 `target remote :25000` 连接到qemu


![[Ubuntu gdb调试.png]]


视频中老师使用的linux版本并不是ubuntu 所以指令在ubuntu中并不适用，需要更改！！ 

首先要手动读取内核：

`file kernel/kernel` 

之后就可以看到详细的输出了 但是没有视频中的纤细输出

b ~~  给某个位置打断点

`b _entry` `b main`

`c`  (Continue) - 继续执行直到下一个断点

`si`  (Step Instruction) - 单步执行一条汇编指令

`n` (Next) - 单步执行一行源代码


![[视图查看.png]]


`layout asm`  :

  纯汇编视图

- 只显示**汇编指令**，适用于低级调试（如 OS 内核、Bootloader）。
- 适合用 `si`（单步执行指令）进行逐条汇编指令调试。

 **`layout split`: 
 
源代码 + 汇编混合视图

- **上半部分**：显示源码（C 代码）。
- **下半部分**：显示对应的**汇编指令**。
- 适用于调试 C 语言时，同时观察 C 代码和编译后的汇编代码。

ctrl + x a 退出

---


## lab 2： System-calls

测评脚本修改为：

```bash
sudo python3 grade-lab-syscall trace
```


####  System call tracing

添加一个系统调用跟踪功能，该功能可能会在调试后续实验时为您提供帮助 


## 第二章：页表

页表使得 xv6 能够让不同进程各自的地址空间映射到相同的物理内存上，还能够为不同进程的内存提供保护 

## 插入学习：

#### 锁

xv6 运行在多处理器上，即计算机上有多个单独执行代码的 CPU。这些 CPU 操作同一片地址空间并分享其中的数据结构；xv6 必须建立一种合作机制防止它们互相干扰。即使是在单个处理器上，xv6 也必须使用某些机制来*防止中断处理程序与非中断代码之间互相干扰*

锁提供了互斥功能，保证某个时间点只有一个 CPU 能持有锁

#### 关键：

***你一定要问自己另一个处理器的存在是否会让这行代码无法达到期望的运行结果（因为另一个处理器也可能正在运行该行代码，或者另一行修改这个共享变量的代码），还要考虑如果这里执行一个中断处理程序，又会发生什么情况。***

***一行 C 代码可能由多条机器指令组成，而另一个处理器或者中断可能在这些指令中间影响之。你不能假设这些代码是顺序执行的，也不能假设一个 C 指令是以原子操作执行的。并发使得考虑代码的正确性变得困难。***

#### 竞争条件：

为什么我们需要锁？？


一段链表代码：

```c
struct list{
    int data;
    struct list *next;
};

struct list *list = 0;

void
insert(int data)
{
    struct list *l;
    l = malloc(sizeof *l);
    l->data = data;
    l->next = list;
    list = l;
}
```


**即使可以证明其正确性，实际上这种实现也是错误的，至少不能在多处理器上运行**

 **全局变量 `list` 的潜在问题**:

这意味着所有对链表的操作都会共享同一个 `list`。在多线程环境中，这可能会导致竞争条件（race condition），因为多个线程可能同时修改 `list`。

#### 我的想法：

如何模拟多线程 使这段原本正常运行的代码出现问题？ 打开两个编译器同时执行这段代码可以吗？ 

#### 解答：

打开两个编译器同时执行这段代码并不能模拟多线程环境，因为每个编译器运行的是独立的进程，它们的内存空间是隔离的，不会共享全局变量 `list`

要模拟多线程环境，你需要在同一个进程内创建多个线程，并让这些线程同时操作共享的全局变量 `list`

*竞争问题在于它们的结果由 CPU 执行时间以及其内存操作的先后决定的*


使用c语言模拟多线程编程导致的资源竞争：

```c
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

// 链表结构体
struct list {
    int data;
    struct list* next;
};

struct list* list = NULL;
//CRITICAL_SECTION lock;  // 互斥锁

void insert(int data) {
    struct list* l = malloc(sizeof * l);
    if (l == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    l->data = data;

    // 线程安全的修改
    //EnterCriticalSection(&lock);
    l->next = list;
    list = l;
    //LeaveCriticalSection(&lock);
}

void print_list() {
    struct list* current = list;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

DWORD WINAPI thread_func(LPVOID arg) {
    for (int i = 0; i < 10; i++) {
        insert(i);
    }
    return 0;
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    insert(40);
   // InitializeCriticalSection(&lock);  // 初始化互斥锁

    HANDLE thread1, thread2;

    // 创建两个线程
    thread1 = CreateThread(NULL, 0, thread_func, NULL, 0, NULL);
    thread2 = CreateThread(NULL, 0, thread_func, NULL, 0, NULL);

    // 等待线程结束
   // WaitForSingleObject(thread1, INFINITE);
    //WaitForSingleObject(thread2, INFINITE);

    print_list();

    //DeleteCriticalSection(&lock);  // 释放互斥锁
    return 0;
}

```

#### **进程和线程的关系**

- **进程**：进程是操作系统分配资源的基本单位。每个进程都有独立的内存空间、文件描述符、环境变量等资源。进程之间是相互隔离的，一个进程崩溃通常不会影响其他进程。
    
- **线程**：线程是进程内的执行单元，是*操作系统调度的基本单位*。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源（如堆、全局变量、文件描述符等），但每个线程有自己的栈和寄存器状态。

#### 问题2：

一个进程会没有线程吗？

#### 回答2：
一个进程至少有一个线程，称为主线程（main thread）。当你运行一个普通的 C 程序时，`main` 函数就是在主线程中执行的。这种进程是单线程的。

通过调用线程库（如 `pthread`），可以在一个进程中创建多个线程，这些线程并发执行。

没有线程的进程是不存在的。


---

```c
void
acquire(struct spinlock *lk)
{
    for(;;) {
        if(!lk->locked) {
            lk->locked = 1;
            break;
        }
    }
}
```


这段代码在现代处理器上并不能保证互斥   代码会导致 两个不同的 CPU 持有锁，违反了互斥

若要保证代码的正确，就必须让操作是*原子操作*的 意味着在执行过程中不会被其他线程或 CPU 核心打断。

特殊指令 `xchg`   `xchg(&lk->locked, 1);`

交换了内存中的一个字和一个寄存器的值

交换了什么？

- **内存中的值**：`lk->locked` 的当前值（可能是 `0` 或 `1`）。
    
- **寄存器中的值**：`1`（表示尝试获取锁）。

#### 问题3：

如果两个线程同时运行到xarg这个语句不也还是会造成冲突吗 

#### 回答3：

关键在于 **`xchg` 指令的原子性**。即使两个线程同时运行到 `xchg` 语句，也不会造成冲突，因为 `xchg` 是硬件级别的原子操作。

- CPU 会确保 `xchg` 指令的执行是原子的。即使多个线程同时执行 `xchg`，硬件也会通过锁总线（bus locking）或缓存一致性协议（cache coherence）来保证只有一个线程能够成功执行 `xchg`


---

#### syscall.c

```c

void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    // Use num to lookup the system call function for num, call it,
    // and store its return value in p->trapframe->a0
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}

```


解读



- `myproc()` 是 xv6 中的一个函数，用于获取当前正在运行的进程的 `proc` 结构体指针。

- 系统调用号是通过寄存器 `a7` 传递的。

*寄存器 RS触发器* ：

是cpu用来*暂存指令，数据，地址的电脑存储器*

![[cpu从内存读取数据过程.png]]

作用：

- 从用户进程的陷阱帧中获取系统调用号。
    
- 根据系统调用号找到对应的内核函数并执行。
    
- 将系统调用的结果返回给用户进程。
    
- 如果系统调用号无效，则返回错误信息。


***DMA **插入知识*


#### 遇见错误：

~~~
kernel/syscall.c:129:15: error: ‘sys_close’ undeclared here (not in a function); did you mean ‘sys_closei’?
  129 | [SYS_close]   sys_close,
      |               ^~~~~~~~~
      |               sys_closei
make: *** [<builtin>: kernel/syscall.o] Error 1

~~~

手贱 修改了 extern uint64 sys_close(void); 为 extern uint64 sys_closei(void);  

系统调用表

```c
static uint64 (*syscalls[])(void) = {

[SYS_fork]    sys_fork,

[SYS_exit]    sys_exit,

[SYS_wait]    sys_wait,

[SYS_pipe]    sys_pipe,

[SYS_read]    sys_read,

[SYS_kill]    sys_kill,

[SYS_exec]    sys_exec,

[SYS_fstat]   sys_fstat,

[SYS_chdir]   sys_chdir,

[SYS_dup]     sys_dup,

[SYS_getpid]  sys_getpid,

[SYS_sbrk]    sys_sbrk,

[SYS_sleep]   sys_sleep,

[SYS_uptime]  sys_uptime,

[SYS_open]    sys_open,

[SYS_write]   sys_write,

[SYS_mknod]   sys_mknod,

[SYS_unlink]  sys_unlink,

[SYS_link]    sys_link,

[SYS_mkdir]   sys_mkdir,

[SYS_close]   sys_close,

};
```

#### 问题：

为什么在 char* syscall_name[]数组中如果顺序错误，会导致 在调用

`trace 32 grep hello README`

产生的命令也会不一样（4: syscall read -> 1023） （3: syscall pipe -> 1023）

关键：

`syscall.c`  `proc.c` `sysproc.c` 