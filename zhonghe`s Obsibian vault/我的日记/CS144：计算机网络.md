
## 开始

http get command 浏览器和服务器建立连接 

服务器很少位于NAT之后 因为 互联网的任何人都可以访问它，个人电脑 一般位于NAT之后 

*万维网*

*bitTorrent*  双向字节字符串 

*skype*：

NAT 网路地址转换 

![[NAT.png]]


b 向计算计发送一条信息 表示b已经连接到该计算机  b打开了a的连接 ： 

***反向连接：*** 原本是a呼叫b打开b的连接，但是最终结果是b打开了a的连接 

**1. 问题：这个是a不在NAT之后 如果两个都位于NAT之后如何通信呢？**

第二种服务器 中继：relay

![[中继服务器.png]]


## 四层模型：

作用： 应用程序能够与终端主机进行可靠通信

数据以数据包的形式传输

#### Link： 链路层

链路层的主要任务是确保数据在物理介质上的可靠传输。

*以太网和WiFi* ：

1. 以太网：

- MAC 地址：每个设备都有一个唯一的 MAC 地址，用于标识网络中的设备。

- 广泛应用于局域网（LAN）中。 

***它提供了计算机和其他设备在局部区域内进行数据交换的方式***

- **物理介质**：以太网可以通过双绞线（如 Cat5e、Cat6）、光纤或无线（如 Wi-Fi）传输数据。

2. WiFi :

- Wi-Fi 是一种无线链路层技术，广泛应用于无线局域网（WLAN）中。
- MAC 地址：与以太网类似，Wi-Fi 设备也有唯一的 MAC 地址。
- 数据帧格式：Wi-Fi 使用特定的帧格式来封装数据，包括控制字段、地址字段和数据字段。

 **当手机向笔记本电脑发送数据时，链路层会将数据封装为 Wi-Fi 帧，并通过无线信道传输。**


#### Network: 网络层

通过互联网 端到端的 从 源到目的地传递数据包 是网络中的重要组成部分

网络层数据包：称为 **数据报**：

**报头（Header）** ：  源 IP 地址  目标 IP 地址 等
    


**数据部分（Payload）**： 包含上层协议（如 TCP、UDP）传递的数据。


***网络层将数据报交给链路层  向下传递***

![[数据报传输.png]]


另一方面 ***路由器*** 从*链路层接收数据包*并将其转交给*路由器内的网络层*

![[传输.png]]

####  ip 

尽力 将数据报传送到另一端 但是 ip 可能会无序传送并且可能损坏

所以需要在ip之上运行另一个协议  转移到

#### ***Transport 传输层***

**TCP协议**：TCP协议确保数据传输的可靠性。

**UDP协议**： 不提供任何传送保证


#### Application 应用层

应用程序 在两个端点之间 建立 双向可靠的字节流

![[总体路线.png]]

1. 向下选择 是否可靠传输-》数据包-》 链路层-》 传输-》 重新封装


***ip is the "thin waist"***

这句话强调了 IP 协议在互联网架构中的核心地位。它像沙漏的细腰一样，连接了上层的多样性和下层的多样性，实现了互联网的灵活性和可扩展性。这种设计是互联网成功的关键之一，但也带来了一些挑战，需要在未来的发展中不断改进。


---

## 网络层

IP Datagram -》 IP Data + IP Hdr  

数据报中包含 源地址和目的地址

路由器根据*转发表* 对照地址 一步步向下传递

类比 快递 一站一站传递 但是他不保证我们什么时候才能被送到

ip 丢包了也不会告诉原数据包 

ip不可靠 丢包 错误的路由表会导致到错误的目的地  或者导致数据包被错误的复制

ip是非常简单的最小服务 通信无连接 

#### 问题1：

ip的主要作用是什么？ 为什么ip要有发送数据包到目的地的能力呢？ 而且它的传递还是不可靠的

#### 回答1:

1.  **IP的主要作用**
#### **寻址（Addressing）**

IP为网络中的每个设备分配唯一的逻辑地址（IP地址），用于标识发送方和接收方

2.  **路由（Routing）**

- IP协议定义了数据包如何通过多个网络节点（如路由器）从源地址跳转到目标地址。
    
- 路由器根据IP地址和路由表决定数据包的下一跳路径。

 3. **分片与重组（Fragmentation & Reassembly）**

- 如果数据包大小超过底层网络（如以太网）的最大传输单元（MTU），IP会将其分片传输，并在目的地重组。


IP的核心设计目标是**实现跨网络的通信**，无论底层网络技术（以太网、Wi-Fi、光纤等）如何差异。它的存在解决了以下问题：

- **异构网络互联**：不同物理网络（如局域网和广域网）可能使用不同的寻址方式（如MAC地址），IP通过统一的逻辑地址（IP地址）屏蔽底层差异，实现互联。

***IP协议本身不保证数据包的可靠传输，这是其设计上的刻意选择，原因包括：***

- IP是网络层协议，专注于高效的路由和寻址。可靠性（如丢包重传、顺序纠正）由更高层协议（如TCP）负责。

这种分层设计使得IP轻量化，适应不同应用需求 ， 例如视频流可以容忍丢包，但文件传输需要可靠性
*IP的“不可靠”允许上层协议（如TCP或UDP）根据需求自行处理*

维护成本更低 数据包也会更快的到达 专门硬件加速 

***端到端原则：***

其核心观点是：


> **“某些功能（如可靠性、安全性）最好在通信的最终端点（end hosts）实现，而不是在网络中间节点（如路由器、交换机）上实现。”**

 ip可以让应用程序选择 使用可靠还是不可靠 

#### 为什么 ip服务如此简单？

![[ip server is so simple.png]]


i![[IP Model.png]]

#### 了解ipv4每个字段的作用


![[ipv4.png]]


---

环境配置

直接使用wsl



```c
root@xiaoxinxiaohao:/CS144# 

telnet cs144.keithw.org http

Trying 104.196.238.229...
Connected to cs144.keithw.org.
Escape character is '^]'.

GET /hello HTTP/1.1
Host: cs144.keithw.org
Connection: close

HTTP/1.1 200 OK
Date: Sat, 15 Mar 2025 11:32:33 GMT
Server: Apache
Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT
ETag: "e-57ce93446cb64"
Accept-Ranges: bytes
Content-Length: 14
Connection: close
Content-Type: text/plain

Hello, CS144!
Connection closed by foreign host.

```



~~~
1. **获取邮箱的 SMTP 服务器地址**：
    
    - 不同邮箱提供商的 SMTP 服务器地址不同。以下是一些常见邮箱的 SMTP 服务器：
        
        - Gmail: `smtp.gmail.com`（端口 587 或 465）
            
        - Outlook/Hotmail: `smtp.office365.com`（端口 587）
            
        - Yahoo: `smtp.mail.yahoo.com`（端口 465 或 587）
            
        - QQ 邮箱: `smtp.qq.com`（端口 465 或 587）
~~~


![[telnet.png]]


 netcat -v -l -p 9090（服务器）
 telnet localhost 9090 (客户端)


 #### *通信服务是无连接的*

**通信双方在传输数据前不需要预先建立专用连接，每个数据包（或数据报）独立传输，彼此没有依赖关系**。

 **无需预先建立连接**

- 在发送数据前，发送方和接收方**不需要握手（如TCP的三次握手）**，直接发送数据包。
    
- 例如：IP协议发送数据包时，不会先询问对方是否准备好，而是直接发出。

 **每个数据包独立处理**

- 每个数据包（如IP数据报或UDP报文）**单独寻址和路由**，即使属于同一个通信流，也可能走不同路径。
    
- 例如：发送3个数据包，可能走不同的网络路径，到达顺序也可能不同。

**不维护连接状态**

- 通信双方**不会记录对方的状态**（如TCP的序列号、窗口大小等）。
    
- 例如：IP路由器转发数据包后，不会记住这个包是谁发的，也不会确保它一定能到达。

 **不可靠性（通常）**

- 无连接协议通常不保证数据包一定能到达、按序到达或不重复（如IP和UDP）。
    
- 可靠性（如丢包重传）需要由上层协议（如TCP）或应用程序自己处理。


***省去握手过程（如TCP三次握手），减少延迟***


#### 三次握手

同步 同步 确认

  



---

#### TCP Byte Stream

*互联网协议地址*： 网络层 用来将数据包传递到计算机的地址

*TCP端口*：计算机软件将数据传递到哪个应用程序 


#### 路由器 

通过路由器相连 IP数据包 经过多次跳跃 *跳跃*是连接两个路由器的*链路*

路由器会决定将数据包发送到哪个链路！


如果我是用TCP登录路由器 IP数据包的目标是路由器自己的IP！

**路由器如何做到上述决策？**

**转发表（Routing Table）** ：

是*路由器*或*主机*用于*决定网络数据包*转发*路径*的数据结构。

路由器检查哪个转发表条目的模式最匹配该数据包

简化：

|目标网络|子网掩码|下一跳|接口|优先级|
|---|---|---|---|---|

|   |   |   |   |   |
|---|---|---|---|---|
|0.0.0.0|0.0.0.0|192.168.1.1|eth0|10|

|             |               |         |      |     |
| ----------- | ------------- | ------- | ---- | --- |
| 192.168.1.0 | 255.255.255.0 | 0.0.0.0 | eth0 | 0   |

 ***应用技巧：***

- 后端部署多服务时，合理配置路由可以**隔离内外流量**
    
- 多网卡时，不正确的转发表配置可能导致服务“能 ping 通但连不上”

#### 工具

##### wireshark的使用：

![[抓包分析.png]]


***左下角对应的是网络协议的几个分层***

***右下角对应的是 左侧 16进制 右侧ASCII***

*过滤器的使用：*

显示过滤器 ：

过滤以捕获的数据包
符合条件的进行筛选


捕获过滤器：

只捕获符合条件的数据包


#### 问题：

为什么f12抓取的页面 远程网址都导向了127.0.0.1

~~~
请求 URL:

https://cm.bilibili.com/cm/api/fees/pc

请求方法:

POST

状态代码:

200 OK

远程地址:

127.0.0.1:7890

引用站点策略:

no-referrer-when-downgrade
~~~

#### 解答：

本机的请求**被代理到了本地的一个代理服务上**（一般是你的代理工具，比如 Clash、V2Ray、Shadowrocket、Surge 等），7890 是它默认监听的端口之一。

***关闭代理之后 抓取就正常了 这其中一定有什么奥秘！*** 带解答！！！！！


![[捕获器.png]]

#### 筛选条件 

`(ip.addr == 218.60.18.15 && tcp.port == 80 && ) && (_ws.col.info == "443 → 58972 [ACK] Seq=1 Ack=1201 Win=42496 Len=0")`  
再info中可以右键且选中使用内容作为过滤条件

#### ARP协议

交换MAC地址与IP地址关系的协议

- **相互配合实现通信**：在进行网络通信时，*IP 地址和 MAC 地址相互协作*。当一台设备要向另一台设备发送数据时，*首先*会根据目标设备的 *IP 地址*，通过*网络层*的*路由协议*确定数据传输的*路径*；当数据到达*目标设备所在的局域网*后，就需要通过 *MAC 地址来完成最后的数据传输*，将数据准确无误地发送到目标设备。

- **ARP 协议建立映射**：*ARP*（Address Resolution Protocol）协议的作用是将 *IP 地址*解析为对应的 *MAC 地址*。当设备需要和目标设备通信时，它会先在*本地的 ARP 缓存表*中查找*目标 IP 地址*对应的 *MAC 地址*。如果找不到，就会发送一个 *ARP 请求广播*，*询问局域网*内拥有该 I*P 地址的设备的 MAC 地址*。拥有该 IP 地址的设备会*回应一个 ARP 响应*，告知*自己的 MAC 地址*。这样，发送设备就能够建立起目标 *IP 地址和 MAC 地址的映射关系，进而进行数据传输。*

![[ARP协议.png]]

![[ARP互相应答.png]]

~~~
Target MAC address: TpLinkTechno_8f:8c:fd (64:6e:97:8f:8c:fd) 

这是 其中一个询问的 

Sender MAC address: TpLinkTechno_8f:8c:fd (64:6e:97:8f:8c:fd) 

这个是回复的 ，

我想在电脑上用什么命令查看 是否验证一下哪个是我的设备
~~~

![[我的网卡名称.png]]


**说明 CloudNetwork回复了发问的这个人**

过滤添加 *dns* ： 因为dns是明文传输，所以访问哪个网站 都可以通过dns看到 

例如：： qq.com 

所以通过*加密DNS* 和 *https*加密 就可以避免让黑客得知这串消息

![[编辑DNS.png]]

配置加密之后， 使用wireshark过滤

*ip.addr == 223.5.5.5*

显示的信息都是被加密之后的信息

添加了 *SSLKEYLOGFILE* 密钥解密TCP 使咱们可以观察到http等 get 请求 否则如果使https的加密网站咱们什么都观察不到



##### tracerout：

显示了包到达目标的跳跃路径

traceroute_命令在Windows中的等效命令是 _tracert

![[traceout.png]]


#### 分组交换

它的核心思想是：**将数据拆分成多个小数据块（分组/Packet），独立传输，并在目的地重新组装**

一个**数据包**： 包含自身数据 携带到达目的地所需要的信息

分组交换不需要独占通信链路，而是共享网络资源，从而大幅提高效率。

 **1.分组交换的核心思想：**
 
 **数据分块（Packetization）**
 
- 发送方将完整的数据（如文件、视频、网页请求）拆分成多个**固定或可变大小的分组**。
    
- 每个分组包含：
    
    - **首部（Header）**：源/目标地址、序号、校验和等控制信息。
        
    - **数据部分（Payload）**：实际传输的数据片段。
        
    - **尾部（Trailer，可选）**：错误检测码（如CRC）。

 **独立路由（Independent Routing）**

- 分组通过网络中的**路由器（Router）**逐跳（Hop-by-Hop）转发。
    
- **每个分组可能走不同的路径**（动态路由），最终在目的地按序号重组。


 **统计复用（Statistical Multiplexing）**

- 链路资源被所有分组**共享**，而非独占。
    
- 当网络空闲时，分组可以快速传输；当拥塞时，分组可能需要排队等待。


交换机保存着 每个数据包要发送的下一跳路由，或者交换机自己决策将数据包发送到下一跳！

**交换机**不需要关心什么 只需要将数据包发送！ 

**交换机*核心关注： 快速有效的转发数据包***


 **1. 交换机与路由器的区别核心区别**

|**特性**|**交换机（Switch）**|**路由器（Router）**|
|---|---|---|
|**工作层次**|**数据链路层（Layer 2）**|**网络层（Layer 3）**|
|**主要功能**|基于MAC地址转发数据帧|基于IP地址转发数据包|
|**寻址方式**|使用MAC地址（如 `00:1A:2B:3C:4D`）|使用IP地址（如 `192.168.1.1`）|
|**连接范围**|同一局域网（LAN）内设备互联|不同网络之间互联（如LAN到WAN）|
|**典型应用**|企业内网、家庭局域网|连接家庭网络到互联网（ISP）|



##### 如何有效共享链路！



数据包序列称为*流*是属于同一个端到通信的一组*数据报*

##### 问题：

**每个数据包的独立路由**  怎么理解？

##### 问题：

怎么理解 每个数据包是自包含的 所以交换机不需要直到数据包组或流


### **为什么交换机不需要知道“组”或“流”？**

- **交换机的工作层次**（数据链路层，Layer 2）：
    
    - 交换机**只认MAC地址**，不解析IP或更高层协议（如TCP流）。
        
    - 它通过**MAC地址表**决定将数据帧转发到哪个端口，完全**不关心**：
        
        - 这个包属于哪个TCP连接。
            
        - 前后包是否有逻辑关联。


***交互机需要知道如何清除故障节点*** ！！

如果你请求浏览器，但是出于某种原因 你的电脑关机了！

~~~
**高级交换机的状态保留（需要特别注意）**：

- **三层交换机**：可能维护ARP缓存、路由表等
    
- **带ACL/QoS的交换机**：可能需要维护流分类规则
    
- **SDN交换机**：可能维护OpenFlow流表项

~~~

 
#### 问题：

假如在学校分发的一个路由器下连接着3台电脑，网速是怎么分配的？ 如果三台电脑 其中两台在浏览网页 另一台在下载东西，和 三台同时下载东西会有什么区别 链路是怎么分配的呢？


#### 回答：

- **下载优先抢占带宽**：下载软件（如迅雷、浏览器下载）会通过TCP协议尽可能占用可用带宽，而网页浏览因需求低且间歇性，仅在需要时短暂占用。

- TCP协议的“贪婪性”：下载会持续发送数据包，而网页流量因突发性容易被“挤占”。
    
- 路由器无主动干预时，带宽分配由设备竞争决定。

若同时下载：

1. **带宽分配机制**：
    
    - **平等竞争**：若路由器未配置限速或优先级，三台设备通过TCP协议动态竞争带宽。
        
    - **TCP拥塞控制**：每台设备的TCP连接会根据网络拥塞情况自动调整发送速率（如降低窗口大小），最终趋向均分带宽。
        
2. **实际表现**：
    
    - 总带宽被大致均分（如三台各占约1/3）。
        
    - 若总带宽为100Mbps，每台下载速度约为30-35Mbps（受协议开销影响）。


日常使用是突发性的！

***分层思想：***

每一层专注于*做好自己的工作* 并*为上一层提供明确定义*的服务

邮政服务！


底层抽象掉细节 对于上层的我 不需要直到内部的细节

#### 计算机系统的分层

 1. 模块化
 2. 每一层专注于*做好自己的工作* 并*为上一层提供明确定义*的服务
 3. 复用思想
 4. 关注点分离 不必担心其他的 只需处理自己的事情
 5. 每个功能持续改进
 6. 点对点通信 


### 封装

将分层和分组交换结合起来是发生的结果

当数据从高层（如应用层）向底层（如物理层）传递时，每一层都会在原始数据前（或后）添加本层的协议控制信息（PCI, Protocol Control Information），形成该层的**协议数据单元（PDU, Protocol Data Unit）**。

- **封装过程**：数据在发送端自上而下逐层添加头部/尾部。
    
- **解封装过程**：数据在接收端自下而上逐层移除头部/尾部，还原原始数据。 


*逐层封装：*

Wifi ip tcp http GET http tcp ip Wifi


VPN 虚拟专用网络 ： 打开安全网络 与信任的网络建立安全连接  


**传输层安全协议  TLS：**

 **. TLS的工作层次**

- **位于传输层与应用层之间**（通常基于TCP，如HTTPS的443端口）。
    
- **封装方式**：对应用层数据（如HTTP报文）加密后，交给传输层传输。


~~~
HTTP → TLS加密 → TCP → IP → 网络
~~~


TLS握手是通信双方建立安全连接的关键步骤，简化流程如下：


我打开了VPN之后 在与互联网发送ip包的时候 不是正常发送 而是 发送到VPN连接中方


这样就变成了

~~~
IP TPC TLS ip tcp http tcp ip TLS TCP IP
~~~

TLS 会保证信息的机密性  TLS会话终止于VPN网关的TCP流中

![[TLS.png]]



展示了一个HTTP请求如何经过多层封装（从内到外）：

1. **最内层（应用层）**：
    
    - **HTTP**：原始的Web请求（如 `GET /index.html`）。
        
2. **传输层**：
    
    - **TCP**：添加TCP头部（源/目的端口、序列号等），封装为TCP段。
        
3. **网络层**：
    
    - **IP**：添加IP头部（源/目的IP地址），封装为IP分组。
        
4. **安全层（TLS）**：
    
    - **TLS加密**：对TCP/IP封装后的数据进行加密（添加TLS头部），保护隐私和完整性。
        
    - **此时数据变为“TLS记录”（Presentation Layer）**。
        
5. **VPN的二次封装**：
    
    - **再次经过TCP/IP**：TLS加密后的数据被当作新的应用层数据，重新走一遍协议栈：
        
        - 外层TCP：VPN客户端新建的TCP连接（新的端口号）。
            
        - 外层IP：目标为VPN服务器的公网IP（而非原始目标服务器）。
            
6. **数据链路层**：
    
    - **Ethernet**：最终添加MAC地址和帧尾，通过物理网络发送。


直观表示

```c
原始HTTP请求 → TCP → IP → TLS加密 → 作为新数据 → 外层TCP → 外层IP → Ethernet
（应用层）   （传输层）（网络层）（安全层）       （VPN的传输层）（VPN的网络层）（链路层）
```

外层TCP/IP的作用是将加密后的数据路由到VPN服务器，


*为了让双方进行通信 他们需要就交换的信息达成一致*

必须是双方 会的语言相同才能通信 

中文和中文才能通信

对于计算机说： 消息字段 排列方式 格式 表示方式要达成一致

网卡 在内存中来回存储发送消息 然后软件访问

### Computer Memory


![[字节序.png]]




这张截图解释了计算机中 **字节序（Endianness）** 的概念，即多字节数据（如16位、32位整数）在内存中的存储顺序。以下是逐步解析：

---

### **1. 核心问题：多字节数据的存储顺序**

- **示例数值**：十进制 `1024` 的十六进制是 `0x0400`（占2字节）。
    
- **关键问题**：这两个字节（`0x04` 和 `0x00`）在内存中如何排列？
    
    - 是高字节在前（`0x04`）还是低字节在前（`0x00`）？
        
    - 这取决于系统的 **字节序**（大端序或小端序）。


图片中的第一种适合计算机观看
图片中的第二种适合人类阅读


![[计算大小端.png]]


    **字节序（Byte Order）**：

- **大端序（Big-Endian）**：高位字节存储在低地址（网络字节序默认采用大端序）。
    
- **小端序（Little-Endian）**：低位字节存储在低地址（x86等处理器采用小端序）


1. **问题场景**：
    
    - 网络数据包中的多字节数据（如端口号、IP地址）总是以**网络字节序（大端序）**传输。
        
    - 如果程序在x86主机（小端序）上直接比较网络字节序的值，会导致错误。例如：
        
        - 端口号 `80`（十六进制 `0x0050`）在：
            
            - 网络字节序中存储为 `0x00 0x50`（大端序）。
                
            - x86主机内存中可能存储为 `0x50 0x00`（小端序）。
                
        - 直接比较 `packet->port == http_port` 会因为字节序不同而失败。


#### ***小心处理网络数据***

子网掩码： 子网掩码决定了**IP地址的前多少位是网络号，后面是主机号**。

| 子网掩码          | 二进制前缀     | 含义说明            |     |
| ------------- | --------- | --------------- | --- |
| 255.255.255.0 | 前 24 位是 1 | 前 24 位相同表示在同一网段 |     |
| 255.255.252.0 | 前 22 位是 1 | 前 22 位相同才算同网段   |     |
| 255.128.0.0   | 前 9 位是 1  | 只要求前 9 位相同      |     |

 ip 192.168.0.106

netmask 0xffffff00

以192.168.0 开头的地址发送ip数据包 可以直接发送 不以这个开头则需要通过路由器发送

 确定网络地址（Network Address）

网络地址 = `IP 地址` 与 `子网掩码` 做按位与（bitwise AND）



#### 分析是否为同一网段

 ### ✅ 举个例子说明第一行：

- **Source:** `128.34.1.15`
    
- **Destination:** `128.35.1.15`
    
- **Netmask:** `255.255.0.0` （= 16位）
    

#### 步骤：

1. 把 IP 地址和 Netmask 转换成二进制。
    
2. 分别对 Source 和 Destination 与 Netmask 做按位与。
    
3. 看结果是否一致。
    

#### 计算：

- `128.34.1.15` = `10000000.00100010.00000001.00001111`
    
- `128.35.1.15` = `10000000.00100011.00000001.00001111`
    
- `255.255.0.0` = `11111111.11111111.00000000.00000000`
    

做 AND：

- `128.34.1.15 & Netmask` = `10000000.00100010.00000000.00000000` = `128.34.0.0`
    
- `128.35.1.15 & Netmask` = `10000000.00100011.00000000.00000000` = `128.35.0.0`
    

→ 不一样，所以 **不在同一个网络**。✅ 表格上写了 `NO`


#### ipv4如何分配并且管理


### 最长前缀匹配


路由器通常使用的算法 ： 将包发送到哪个链路！

路由器中包含转发表 ： 一个转发表包含一组部分 ip地址

哪个表发表最匹配该包  并将该包沿着与该转发表项相关链路转发

默认转发表匹配任何路由

![[Pasted image 20250412092453.png]]


### ARP

需要某种方法 将第三层的网络层地址 映射到对应的第二层链路层地址

### 网关的作用

发送数据包时首先要判断是否在同一网段

#### **连接不同网络**

- **场景**：当设备（如你的电脑）需要访问其他网络（如互联网或另一个子网）时，数据必须通过网关。  
    **示例**：
    
    - 你的本地IP是 `192.168.0.5`（私有地址），要访问公网IP `171.43.22.5`，数据会先发送到网关 `192.168.0.1`，再由网关转发到外部网络。
        
    - 在图中，设备A（`192.168.0.5`）通过网关 `192.168.0.1` 与设备B（`171.43.22.5`）通信。


####  **快速验证方法**

- 如果子网掩码是 `255.255.255.0`（`/24`），只需将IP地址的最后一位置 `0`，即为网络号。  
    **例如**：  
    `192.168.0.5` → 网络号 `192.168.0.0`。

- **IP地址**：`10.1.2.100`，子网掩码 `255.255.0.0`（`/16`）
    
    - 网络号：`10.1.0.0`（后16位置 `0`）。
        
- **IP地址**：`172.16.5.3`，子网掩码 `255.255.255.128`（`/25`）
    
    - 需要二进制计算：保留前25位，后7位置 `0`。


按位与同时为1才为1 否则为0 


