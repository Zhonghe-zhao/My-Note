
### 进程的一些列初始化

```c
// Per-process state

struct proc {

  struct spinlock lock;

  

  // p->lock must be held when using these:

  enum procstate state;        // Process state

  struct proc *parent;         // Parent process

  void *chan;                  // If non-zero, sleeping on chan

  int killed;                  // If non-zero, have been killed

  int xstate;                  // Exit status to be returned to parent's wait

  int pid;                     // Process ID

  

  // these are private to the process, so p->lock need not be held.

  uint64 kstack;               // Virtual address of kernel stack

  uint64 sz;                   // Size of process memory (bytes)

  pagetable_t pagetable;       // User page table

  struct trapframe *trapframe; // data page for trampoline.S

  struct context context;      // swtch() here to run process

  struct file *ofile[NOFILE];  // Open files

  struct inode *cwd;           // Current directory

  char name[16];               // Process name (debugging)

};
```


```c
  

// Set up first user process.

void

userinit(void)

{

  struct proc *p;

  p = allocproc();

  initproc = p;

  // allocate one user page and copy init's instructions

  // and data into it.

  uvminit(p->pagetable, initcode, sizeof(initcode));

  p->sz = PGSIZE;


  // prepare for the very first "return" from kernel to user.

  p->trapframe->epc = 0;      // user program counter

  p->trapframe->sp = PGSIZE;  // user stack pointer
 

  safestrcpy(p->name, "initcode", sizeof(p->name));

  p->cwd = namei("/");


  p->state = RUNNABLE;


  release(&p->lock);

}
```


```c
static struct proc*

allocproc(void)

{

  struct proc *p;

  

  for(p = proc; p < &proc[NPROC]; p++) {

    acquire(&p->lock);

    if(p->state == UNUSED) {

      goto found;

    } else {

      release(&p->lock);

    }

  }

  return 0;

  

found:

  p->pid = allocpid();

  

  // Allocate a trapframe page.

  if((p->trapframe = (struct trapframe *)kalloc()) == 0){

    release(&p->lock);

    return 0;

  }

  

  // An empty user page table.

  p->pagetable = proc_pagetable(p);

  if(p->pagetable == 0){

    freeproc(p);

    release(&p->lock);

    return 0;

  }

  

  // Set up new context to start executing at forkret,

  // which returns to user space.

  memset(&p->context, 0, sizeof(p->context));

  p->context.ra = (uint64)forkret;

  p->context.sp = p->kstack + PGSIZE;

  

  return p;

}
```

## 自旋锁的提出背景

由于在多处理器环境中某些资源的有限性，有时需要互斥访问(mutual exclusion)，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取到锁。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？

通常有两种处理方式：一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做`互斥锁`。

#### 临界区

**临界区** 是指程序中访问 **共享资源**（如全局变量、数据结构、硬件设备等）的代码段，这些资源在同一时刻只能被一个线程或进程安全地访问。其核心特征是：

- **共享性**：涉及多线程/进程共用的数据或设备
    
- **排他性**：必须通过同步机制保证独占访问
    

---

### **为什么需要临界区？**

#### 1. **数据竞争（Data Race）示例**

c

复制

// 全局共享变量
int counter = 0;

void increment() {
    counter++; // 这不是原子操作！
}

因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下

### **没有自旋锁的情况下会发生什么？**

如果使用的是**普通互斥锁（Mutex）**：

- 当一个线程获取不到锁时，操作系统会将其**挂起**（block），让出 CPU。
    
- 操作系统需要进行 **进程/线程调度**，选择其他线程运行，等锁释放后再唤醒这个线程。
    
- **线程切换的代价很高**，包括：
    
    - **用户态 → 内核态的切换**（需要陷入内核管理）
        
    - **保存和恢复线程上下文**（寄存器、栈、程序计数器等）
        
    - **调度开销**（选择哪个线程执行）